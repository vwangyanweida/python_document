"datetime" --- 基本的日期和时间类型
***********************************

**源代码：** Lib/datetime.py

======================================================================

The "datetime" module supplies classes for manipulating dates and
times.

While date and time arithmetic is supported, the focus of the
implementation is on efficient attribute extraction for output
formatting and manipulation.

参见:

  模块 "calendar"
     日历相关函数

  模块 "time"
     时间的访问和转换

  Package dateutil
     Third-party library with expanded time zone and parsing support.


Aware and Naive Objects
=======================

Date and time objects may be categorized as "aware" or "naive."

With sufficient knowledge of applicable algorithmic and political time
adjustments, such as time zone and daylight saving time information,
an **aware** object can locate itself relative to other aware objects.
An aware object represents a specific moment in time that is not open
to interpretation. [1]

A **naive** object does not contain enough information to
unambiguously locate itself relative to other date/time objects.
Whether a naive object represents Coordinated Universal Time (UTC),
local time, or time in some other timezone is purely up to the
program, just like it is up to the program whether a particular number
represents metres, miles, or mass. Naive objects are easy to
understand and to work with, at the cost of ignoring some aspects of
reality.

For applications requiring aware objects, "datetime" and "time"
objects have an optional time zone information attribute, "tzinfo",
that can be set to an instance of a subclass of the abstract "tzinfo"
class. These "tzinfo" objects capture information about the offset
from UTC time, the time zone name, and whether daylight saving time is
in effect.

Only one concrete "tzinfo" class, the "timezone" class, is supplied by
the "datetime" module. The "timezone" class can represent simple
timezones with fixed offsets from UTC, such as UTC itself or North
American EST and EDT timezones. Supporting timezones at deeper levels
of detail is up to the application. The rules for time adjustment
across the world are more political than rational, change frequently,
and there is no standard suitable for every application aside from
UTC.


常量
====

The "datetime" module exports the following constants:

datetime.MINYEAR

   "date" 或者 "datetime" 对象允许的最小年份。 常量 "MINYEAR" 是 "1"
   。

datetime.MAXYEAR

   "date" 或 "datetime" 对象允许最大的年份。常量 "MAXYEAR" 是 "9999"
   。


有效的类型
==========

class datetime.date

   一个理想化的无知型日期，它假设当今的公历在过去和未来永远有效。 属性
   : "year", "month", and "day"。

class datetime.time

   An idealized time, independent of any particular day, assuming that
   every day has exactly 24*60*60 seconds.  (There is no notion of
   "leap seconds" here.) Attributes: "hour", "minute", "second",
   "microsecond", and "tzinfo".

class datetime.datetime

   日期和时间的结合。属性："year", "month", "day", "hour", "minute",
   "second", "microsecond", and "tzinfo".

class datetime.timedelta

   表示两个 "date" 对象或者 "time" 对象,或者 "datetime" 对象之间的时间
   间隔，精确到微秒。

class datetime.tzinfo

   An abstract base class for time zone information objects. These are
   used by the "datetime" and "time" classes to provide a customizable
   notion of time adjustment (for example, to account for time zone
   and/or daylight saving time).

class datetime.timezone

   一个实现了 "tzinfo" 抽象基类的子类，用于表示相对于 世界标准时间（
   UTC）的偏移量。

   3.2 新版功能.

这些类型的对象都是不可变的。

子类关系

   object
       timedelta
       tzinfo
           timezone
       time
       date
           datetime


Common Properties
-----------------

The "date", "datetime", "time", and "timezone" types share these
common features:

* 这些类型的对象都是不可变的。

* Objects of these types are hashable, meaning that they can be used
  as dictionary keys.

* Objects of these types support efficient pickling via the "pickle"
  module.


Determining if an Object is Aware or Naive
------------------------------------------

"date"  类型的对象都是无知型的。

An object of type "time" or "datetime" may be aware or naive.

A "datetime" object *d* is aware if both of the following hold:

1. "d.tzinfo" 不能为 "None"

2. "d.tzinfo.utcoffset(d)" 不会返回 "None"

Otherwise, *d* is naive.

A "time" object *t* is aware if both of the following hold:

1. "t.tzinfo" 不能为 "None"

2. "t.tzinfo.utcoffset(None)" does not return "None".

Otherwise, *t* is naive.

The distinction between aware and naive doesn't apply to "timedelta"
objects.


"timedelta" 类对象
==================

"timedelta" 对象表示两个 date 或者 time 的时间间隔。

class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

   All arguments are optional and default to "0". Arguments may be
   integers or floats, and may be positive or negative.

   Only *days*, *seconds* and *microseconds* are stored internally.
   Arguments are converted to those units:

   * 1毫秒会转换成1000微秒。

   * 1分钟会转换成60秒。

   * 1小时会转换成3600秒。

   * 1星期会转换成7天。

   days, seconds, microseconds 本身也是标准化的，以保证表达方式的唯一
   性，例：

   * "0 <= microseconds < 1000000"

   * "0 <= seconds < 3600*24" (一天的秒数)

   * "-999999999 <= days <= 999999999"

   The following example illustrates how any arguments besides *days*,
   *seconds* and *microseconds* are "merged" and normalized into those
   three resulting attributes:

      >>> from datetime import timedelta
      >>> delta = timedelta(
      ...     days=50,
      ...     seconds=27,
      ...     microseconds=10,
      ...     milliseconds=29000,
      ...     minutes=5,
      ...     hours=8,
      ...     weeks=2
      ... )
      >>> # Only days, seconds, and microseconds remain
      >>> delta
      datetime.timedelta(days=64, seconds=29156, microseconds=10)

   If any argument is a float and there are fractional microseconds,
   the fractional microseconds left over from all arguments are
   combined and their sum is rounded to the nearest microsecond using
   round-half-to-even tiebreaker. If no argument is a float, the
   conversion and normalization processes are exact (no information is
   lost).

   如果标准化后的 days 数值超过了指定范围，将会抛出 "OverflowError" 异
   常。

   Note that normalization of negative values may be surprising at
   first. For example:

      >>> from datetime import timedelta
      >>> d = timedelta(microseconds=-1)
      >>> (d.days, d.seconds, d.microseconds)
      (-1, 86399, 999999)

类属性：

timedelta.min

   The most negative "timedelta" object, "timedelta(-999999999)".

timedelta.max

   The most positive "timedelta" object, "timedelta(days=999999999,
   hours=23, minutes=59, seconds=59, microseconds=999999)".

timedelta.resolution

   两个不相等的 "timedelta" 类对象最小的间隔为
   "timedelta(microseconds=1)"。

需要注意的是，因为标准化的缘故，"timedelta.max" > "-timedelta.min"，
"-timedelta.max" 不可以表示一个 "timedelta" 类对象。

实例属性（只读）：

+--------------------+----------------------------------------------+
| 属性               | 值                                           |
|====================|==============================================|
| "days"             | -999999999 至 999999999 ，含999999999        |
+--------------------+----------------------------------------------+
| "seconds"          | 0 至 86399，包含86399                        |
+--------------------+----------------------------------------------+
| "microseconds"     | 0 至 999999，包含999999                      |
+--------------------+----------------------------------------------+

支持的运算：

+----------------------------------+-------------------------------------------------+
| 运算                             | 结果                                            |
|==================================|=================================================|
| "t1 = t2 + t3"                   | *t2* 和 *t3* 的和。 运算后 *t1*-*t2* == *t3*    |
|                                  | and *t1*-*t3* == *t2* 必 为真值。(1)            |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 - t3"                   | *t2* 减 *t3* 的差。 运算后 *t1* == *t2* - *t3*  |
|                                  | and *t2* == *t1* + *t3* 必为真值。 (1)(6)       |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 * i or t1 = i * t2"     | 乘以一个整数。运算后假如 "i != 0" 则 *t1* // i  |
|                                  | == *t2* 必为真值。                              |
+----------------------------------+-------------------------------------------------+
|                                  | In general, *t1* * i == *t1* * (i-1) + *t1* is  |
|                                  | true. (1)                                       |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 * f or t1 = f * t2"     | 乘以一个浮点数，结果会被舍入到 timedelta 最接近 |
|                                  | 的整数倍。 精度使用四舍 五偶入奇不入规则。      |
+----------------------------------+-------------------------------------------------+
| "f = t2 / t3"                    | 总时间 *t2* 除以间隔单位 *t3* (3)。 返回一个    |
|                                  | "float" 对象。                                  |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 / f or t1 = t2 / i"     | 除以一个浮点数或整数。 结果会被舍入到 timedelta |
|                                  | 最接近的整数倍。 精度 使用四舍五偶入奇不入规则  |
|                                  | 。                                              |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 // i" or "t1 = t2 //    | 计算底数，其余部分（如果有）将被丢弃。在第二种  |
| t3"                              | 情况下，将返回整数。 （3 ）                     |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 % t3"                   | 余数为一个 "timedelta" 对象。(3)                |
+----------------------------------+-------------------------------------------------+
| "q, r = divmod(t1, t2)"          | 通过 : "q = t1 // t2" (3) and "r = t1 % t2" 计  |
|                                  | 算出商和余数。q是一个整 数，r是一个 "timedelta" |
|                                  | 对象。                                          |
+----------------------------------+-------------------------------------------------+
| "+t1"                            | 返回一个相同数值的 "timedelta" 对象。           |
+----------------------------------+-------------------------------------------------+
| "-t1"                            | 等价于 "timedelta"(-*t1.days*, -*t1.seconds*,   |
|                                  | -*t1.microseconds*), 和 *t1** -1. (1)(4)        |
+----------------------------------+-------------------------------------------------+
| "abs(t)"                         | 当 "t.days >= 0``时等于 +\ *t*, 当 ``t.days <   |
|                                  | 0" 时 -*t* 。 (2)                               |
+----------------------------------+-------------------------------------------------+
| "str(t)"                         | 返回一个形如 "[D day[s], ][H]H:MM:SS[.UUUUUU]"  |
|                                  | 的字符串，当 "t" 为负数 的时候，  D 也为负数。  |
|                                  | (5)                                             |
+----------------------------------+-------------------------------------------------+
| "repr(t)"                        | 返回一个 "timedelta" 对象的字符串表示形式，作为 |
|                                  | 附带正规属性值的构造器 调用。                   |
+----------------------------------+-------------------------------------------------+

注释:

1. 结果正确，但可能会溢出。

2. 结果正确，不会溢出。

3. 除以0将会抛出异常  "ZeroDivisionError" 。

4. -*timedelta.max* 不是一个 "timedelta" 类对象。

5. "timedelta" 对象的字符串表示形式类似于其内部表示形式被规范化。对
   于 负时间增量，这会导致一些不寻常的结果。例如:

      >>> timedelta(hours=-5)
      datetime.timedelta(days=-1, seconds=68400)
      >>> print(_)
      -1 day, 19:00:00

6. 表达式 "t2 - t3" 通常与 "t2 + (-t3)" 是等价的，除非 t3 等于
   "timedelta.max"; 在这种情况下前者会返回结果，而后者则会溢出。

In addition to the operations listed above, "timedelta" objects
support certain additions and subtractions with "date" and "datetime"
objects (see below).

在 3.2 版更改: Floor division and true division of a "timedelta"
object by another "timedelta" object are now supported, as are
remainder operations and the "divmod()" function. True division and
multiplication of a "timedelta" object by a "float" object are now
supported.

Comparisons of "timedelta" objects are supported, with some caveats.

The comparisons "==" or "!=" *always* return a "bool", no matter the
type of the compared object:

   >>> from datetime import timedelta
   >>> delta1 = timedelta(seconds=57)
   >>> delta2 = timedelta(hours=25, seconds=2)
   >>> delta2 != delta1
   True
   >>> delta2 == 5
   False

For all other comparisons (such as "<" and ">"), when a "timedelta"
object is compared to an object of a different type, "TypeError" is
raised:

   >>> delta2 > delta1
   True
   >>> delta2 > 5
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: '>' not supported between instances of 'datetime.timedelta' and 'int'

In Boolean contexts, a "timedelta" object is considered to be true if
and only if it isn't equal to "timedelta(0)".

实例方法：

timedelta.total_seconds()

   返回时间间隔包含了多少秒。造价于 "td / timedelta(seconds=1)"。对于
   其它单位可以直接使用除法的形式 (例如  "td /
   timedelta(microseconds=1)")。

   需要注意的是，时间间隔较大时，这个方法的结果中的微秒将会失真（大多
   数平台上大于270年视为一个较大的时间间隔）。

   3.2 新版功能.


class:*timedelta* 用法示例
--------------------------

An additional example of normalization:

   >>> # Components of another_year add up to exactly 365 days
   >>> from datetime import timedelta
   >>> year = timedelta(days=365)
   >>> another_year = timedelta(weeks=40, days=84, hours=23,
   ...                          minutes=50, seconds=600)
   >>> year == another_year
   True
   >>> year.total_seconds()
   31536000.0

Examples of "timedelta" arithmetic:

   >>> from datetime import timedelta
   >>> year = timedelta(days=365)
   >>> ten_years = 10 * year
   >>> ten_years
   datetime.timedelta(days=3650)
   >>> ten_years.days // 365
   10
   >>> nine_years = ten_years - year
   >>> nine_years
   datetime.timedelta(days=3285)
   >>> three_years = nine_years // 3
   >>> three_years, three_years.days // 365
   (datetime.timedelta(days=1095), 3)


"date" 对象
===========

A "date" object represents a date (year, month and day) in an
idealized calendar, the current Gregorian calendar indefinitely
extended in both directions.

January 1 of year 1 is called day number 1, January 2 of year 1 is
called day number 2, and so on. [2]

class datetime.date(year, month, day)

   All arguments are required. Arguments must be integers, in the
   following ranges:

   * "MINYEAR <= year <= MAXYEAR"

   * "1 <= month <= 12"

   * "1 <= 日期 <= 给定年月对应的天数"

   如果参数不在这些范围内，则抛出 "ValueError" 异常。

其它构造器，所有的类方法：

classmethod date.today()

   返回当前的本地日期。

   This is equivalent to "date.fromtimestamp(time.time())".

classmethod date.fromtimestamp(timestamp)

   Return the local date corresponding to the POSIX timestamp, such as
   is returned by "time.time()".

   This may raise "OverflowError", if the timestamp is out of the
   range of values supported by the platform C "localtime()" function,
   and "OSError" on "localtime()" failure. It's common for this to be
   restricted to years from 1970 through 2038. Note that on non-POSIX
   systems that include leap seconds in their notion of a timestamp,
   leap seconds are ignored by "fromtimestamp()".

   在 3.3 版更改: 引发 "OverflowError" 而不是 "ValueError"，如果时间戳
   数值超出所在平台 C "localtime()" 函数的支持范围的话，并会在
   "localtime()" 出错时引发 "OSError" 而不是 "ValueError"。

classmethod date.fromordinal(ordinal)

   Return the date corresponding to the proleptic Gregorian ordinal,
   where January 1 of year 1 has ordinal 1.

   "ValueError" is raised unless "1 <= ordinal <=
   date.max.toordinal()". For any date *d*,
   "date.fromordinal(d.toordinal()) == d".

classmethod date.fromisoformat(date_string)

   Return a "date" corresponding to a *date_string* given in the
   format "YYYY-MM-DD":

      >>> from datetime import date
      >>> date.fromisoformat('2019-12-04')
      datetime.date(2019, 12, 4)

   This is the inverse of "date.isoformat()". It only supports the
   format "YYYY-MM-DD".

   3.7 新版功能.

classmethod date.fromisocalendar(year, week, day)

   返回指定 year, week 和 day 所对应 ISO 历法日期的 "date"。 这是函数
   "date.isocalendar()" 的逆操作。

   3.8 新版功能.

类属性：

date.min

   最小的日期 "date(MINYEAR, 1, 1)" 。

date.max

   最大的日期 ，"date(MAXYEAR, 12, 31)"。

date.resolution

   两个日期对象的最小间隔，"timedelta(days=1)"。

实例属性（只读）：

date.year

   在 "MINYEAR" 和 "MAXYEAR" 之间，包含边界。

date.month

   1 至 12（含）

date.day

   返回1到指定年月的天数间的数字。

支持的运算：

+---------------------------------+------------------------------------------------+
| 运算                            | 结果                                           |
|=================================|================================================|
| "date2 = date1 + timedelta"     | *date2* is "timedelta.days" days removed from  |
|                                 | *date1*. (1)                                   |
+---------------------------------+------------------------------------------------+
| "date2 = date1 - timedelta"     | 计算 *date2* 的值使得 "date2 + timedelta ==    |
|                                 | date1"。 (2)                                   |
+---------------------------------+------------------------------------------------+
| "timedelta = date1 - date2"     | (3)                                            |
+---------------------------------+------------------------------------------------+
| "date1 < date2"                 | 如果 *date1* 的时间在 *date2* 之前则认为       |
|                                 | *date1* 小于 *date2* 。 (4)                    |
+---------------------------------+------------------------------------------------+

注释:

1. *date2* is moved forward in time if "timedelta.days > 0", or
   backward if "timedelta.days < 0". Afterward "date2 - date1 ==
   timedelta.days". "timedelta.seconds" and "timedelta.microseconds"
   are ignored. "OverflowError" is raised if "date2.year" would be
   smaller than "MINYEAR" or larger than "MAXYEAR".

2. "timedelta.seconds" 和 "timedelta.microseconds" 会被忽略。

3. This is exact, and cannot overflow. timedelta.seconds and
   timedelta.microseconds are 0, and date2 + timedelta == date1 after.

4. In other words, "date1 < date2" if and only if
   "date1.toordinal() < date2.toordinal()". Date comparison raises
   "TypeError" if the other comparand isn't also a "date" object.
   However, "NotImplemented" is returned instead if the other
   comparand has a "timetuple()" attribute. This hook gives other
   kinds of date objects a chance at implementing mixed-type
   comparison. If not, when a "date" object is compared to an object
   of a different type, "TypeError" is raised unless the comparison is
   "==" or "!=". The latter cases return "False" or "True",
   respectively.

In Boolean contexts, all "date" objects are considered to be true.

实例方法：

date.replace(year=self.year, month=self.month, day=self.day)

   Return a date with the same value, except for those parameters
   given new values by whichever keyword arguments are specified.

   示例:

      >>> from datetime import date
      >>> d = date(2002, 12, 31)
      >>> d.replace(day=26)
      datetime.date(2002, 12, 26)

date.timetuple()

   Return a "time.struct_time" such as returned by "time.localtime()".

   The hours, minutes and seconds are 0, and the DST flag is -1.

   "d.timetuple()" is equivalent to:

      time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))

   where "yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1"
   is the day number within the current year starting with "1" for
   January 1st.

date.toordinal()

   Return the proleptic Gregorian ordinal of the date, where January 1
   of year 1 has ordinal 1. For any "date" object *d*,
   "date.fromordinal(d.toordinal()) == d".

date.weekday()

   返回一个整数代表星期几，星期一为0，星期天为6。例如， "date(2002,
   12, 4).weekday() == 2"，表示的是星期三。参阅 "isoweekday()"。

date.isoweekday()

   返回一个整数代表星期几，星期一为1，星期天为7。例如："date(2002, 12,
   4).isoweekday() == 3",表示星期三。参见 "weekday()", "isocalendar()"
   。

date.isocalendar()

   返回一个三元元组，(ISO year, ISO week number, ISO weekday) 。

   The ISO calendar is a widely used variant of the Gregorian
   calendar. [3]

   The ISO year consists of 52 or 53 full weeks, and where a week
   starts on a Monday and ends on a Sunday. The first week of an ISO
   year is the first (Gregorian) calendar week of a year containing a
   Thursday. This is called week number 1, and the ISO year of that
   Thursday is the same as its Gregorian year.

   For example, 2004 begins on a Thursday, so the first week of ISO
   year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan
   2004:

      >>> from datetime import date
      >>> date(2003, 12, 29).isocalendar()
      (2004, 1, 1)
      >>> date(2004, 1, 4).isocalendar()
      (2004, 1, 7)

date.isoformat()

   Return a string representing the date in ISO 8601 format, "YYYY-MM-
   DD":

      >>> from datetime import date
      >>> date(2002, 12, 4).isoformat()
      '2002-12-04'

   This is the inverse of "date.fromisoformat()".

date.__str__()

   对于日期对象 *d*, "str(d)" 等价于 "d.isoformat()" 。

date.ctime()

   Return a string representing the date:

      >>> from datetime import date
      >>> date(2002, 12, 4).ctime()
      'Wed Dec  4 00:00:00 2002'

   "d.ctime()" 等效于:

      time.ctime(time.mktime(d.timetuple()))

   on platforms where the native C "ctime()" function (which
   "time.ctime()" invokes, but which "date.ctime()" does not invoke)
   conforms to the C standard.

date.strftime(format)

   返回一个由显式格式字符串所指明的代表日期的字符串。 表示时、分或秒的
   格式代码值将为 0。 要获取格式指令的完整列表请参阅 strftime() 和
   strptime() 的行为。

date.__format__(format)

   与 "date.strftime()" 相同。 此方法使得为 "date" 对象指定以 格式化字
   符串字面值 表示的格式化字符串以及使用 "str.format()" 进行格式化成为
   可能。 要获取格式指令的完整列表，请参阅 strftime() 和 strptime() 的
   行为。


class:*date* 用法示例
---------------------

计算距离特定事件天数的例子:

   >>> import time
   >>> from datetime import date
   >>> today = date.today()
   >>> today
   datetime.date(2007, 12, 5)
   >>> today == date.fromtimestamp(time.time())
   True
   >>> my_birthday = date(today.year, 6, 24)
   >>> if my_birthday < today:
   ...     my_birthday = my_birthday.replace(year=today.year + 1)
   >>> my_birthday
   datetime.date(2008, 6, 24)
   >>> time_to_birthday = abs(my_birthday - today)
   >>> time_to_birthday.days
   202

More examples of working with "date":

   >>> from datetime import date
   >>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001
   >>> d
   datetime.date(2002, 3, 11)

   >>> # Methods related to formatting string output
   >>> d.isoformat()
   '2002-03-11'
   >>> d.strftime("%d/%m/%y")
   '11/03/02'
   >>> d.strftime("%A %d. %B %Y")
   'Monday 11. March 2002'
   >>> d.ctime()
   'Mon Mar 11 00:00:00 2002'
   >>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, "day", "month")
   'The day is 11, the month is March.'

   >>> # Methods for to extracting 'components' under different calendars
   >>> t = d.timetuple()
   >>> for i in t:     
   ...     print(i)
   2002                # year
   3                   # month
   11                  # day
   0
   0
   0
   0                   # weekday (0 = Monday)
   70                  # 70th day in the year
   -1
   >>> ic = d.isocalendar()
   >>> for i in ic:    
   ...     print(i)
   2002                # ISO year
   11                  # ISO week number
   1                   # ISO day number ( 1 = Monday )

   >>> # A date object is immutable; all operations produce a new object
   >>> d.replace(year=2005)
   datetime.date(2005, 3, 11)


"datetime" 对象
===============

A "datetime" object is a single object containing all the information
from a "date" object and a "time" object.

Like a "date" object, "datetime" assumes the current Gregorian
calendar extended in both directions; like a "time" object, "datetime"
assumes there are exactly 3600*24 seconds in every day.

构造器 ：

class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

   The *year*, *month* and *day* arguments are required. *tzinfo* may
   be "None", or an instance of a "tzinfo" subclass. The remaining
   arguments must be integers in the following ranges:

   * "MINYEAR <= year <= MAXYEAR",

   * "1 <= month <= 12",

   * "1 <= day <= 指定年月的天数",

   * "0 <= hour < 24",

   * "0 <= minute < 60",

   * "0 <= second < 60",

   * "0 <= microsecond < 1000000",

   * "fold in [0, 1]".

   如果参数不在这些范围内，则抛出 "ValueError" 异常。

   3.6 新版功能: 增加了 "fold" 参数。

其它构造器，所有的类方法：

classmethod datetime.today()

   Return the current local datetime, with "tzinfo" "None".

   等价于:

      datetime.fromtimestamp(time.time())

   See also "now()", "fromtimestamp()".

   This method is functionally equivalent to "now()", but without a
   "tz" parameter.

classmethod datetime.now(tz=None)

   Return the current local date and time.

   If optional argument *tz* is "None" or not specified, this is like
   "today()", but, if possible, supplies more precision than can be
   gotten from going through a "time.time()" timestamp (for example,
   this may be possible on platforms supplying the C "gettimeofday()"
   function).

   If *tz* is not "None", it must be an instance of a "tzinfo"
   subclass, and the current date and time are converted to *tz*’s
   time zone.

   This function is preferred over "today()" and "utcnow()".

classmethod datetime.utcnow()

   Return the current UTC date and time, with "tzinfo" "None".

   This is like "now()", but returns the current UTC date and time, as
   a naive "datetime" object. An aware current UTC datetime can be
   obtained by calling "datetime.now(timezone.utc)". See also "now()".

   警告: Because naive "datetime" objects are treated by many
     "datetime" methods as local times, it is preferred to use aware
     datetimes to represent times in UTC. As such, the recommended way
     to create an object representing the current time in UTC  by
     calling "datetime.now(timezone.utc)".

classmethod datetime.fromtimestamp(timestamp, tz=None)

   返回对应于 POSIX 时间戳例如 "time.time()" 的返回值的本地日期和时间
   。 如果可选参数 *tz* 为 "None" 或未指定，时间戳会被转换为所在平台的
   本地日期和时间，返回的 "datetime" 对象将为天真型。

   If *tz* is not "None", it must be an instance of a "tzinfo"
   subclass, and the timestamp is converted to *tz*’s time zone.

   "fromtimestamp()" may raise "OverflowError", if the timestamp is
   out of the range of values supported by the platform C
   "localtime()" or "gmtime()" functions, and "OSError" on
   "localtime()" or "gmtime()" failure. It's common for this to be
   restricted to years in 1970 through 2038. Note that on non-POSIX
   systems that include leap seconds in their notion of a timestamp,
   leap seconds are ignored by "fromtimestamp()", and then it's
   possible to have two timestamps differing by a second that yield
   identical "datetime" objects. This method is preferred over
   "utcfromtimestamp()".

   在 3.3 版更改: 引发 "OverflowError" 而不是 "ValueError"，如果时间戳
   数值超出所在平台 C "localtime()" 或 "gmtime()" 函数的支持范围的话。
   并会在 "localtime()" 或 "gmtime()" 出错时引发 "OSError" 而不是
   "ValueError"。

   在 3.6 版更改: "fromtimestamp()" 可能返回 "fold" 值设为 1 的实例。

classmethod datetime.utcfromtimestamp(timestamp)

   Return the UTC "datetime" corresponding to the POSIX timestamp,
   with "tzinfo" "None".  (The resulting object is naive.)

   This may raise "OverflowError", if the timestamp is out of the
   range of values supported by the platform C "gmtime()" function,
   and "OSError" on "gmtime()" failure. It's common for this to be
   restricted to years in 1970 through 2038.

   要得到一个感知型 "datetime" 对象，应调用 "fromtimestamp()":

      datetime.fromtimestamp(timestamp, timezone.utc)

   在 POSIX 兼容的平台上，它等价于以下表达式:

      datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)

   不同之处在于后一种形式总是支持完整年份范围：从 "MINYEAR" 到
   "MAXYEAR" 的开区间。

   警告: Because naive "datetime" objects are treated by many
     "datetime" methods as local times, it is preferred to use aware
     datetimes to represent times in UTC. As such, the recommended way
     to create an object representing a specific timestamp in UTC  by
     calling "datetime.fromtimestamp(timestamp, tz=timezone.utc)".

   在 3.3 版更改: 引发 "OverflowError" 而不是 "ValueError"，如果时间戳
   数值超出所在平台 C "gmtime()" 函数的支持范围的话。 并会在
   "gmtime()" 出错时引发 "OSError" 而不是 "ValueError"。

classmethod datetime.fromordinal(ordinal)

   Return the "datetime" corresponding to the proleptic Gregorian
   ordinal, where January 1 of year 1 has ordinal 1. "ValueError" is
   raised unless "1 <= ordinal <= datetime.max.toordinal()". The hour,
   minute, second and microsecond of the result are all 0, and
   "tzinfo" is "None".

classmethod datetime.combine(date, time, tzinfo=self.tzinfo)

   Return a new "datetime" object whose date components are equal to
   the given "date" object's, and whose time components are equal to
   the given "time" object's. If the *tzinfo* argument is provided,
   its value is used to set the "tzinfo" attribute of the result,
   otherwise the "tzinfo" attribute of the *time* argument is used.

   For any "datetime" object *d*, "d == datetime.combine(d.date(),
   d.time(), d.tzinfo)". If date is a "datetime" object, its time
   components and "tzinfo" attributes are ignored.

   在 3.6 版更改: 增加了 *tzinfo* 参数。

classmethod datetime.fromisoformat(date_string)

   Return a "datetime" corresponding to a *date_string* in one of the
   formats emitted by "date.isoformat()" and "datetime.isoformat()".

   Specifically, this function supports strings in the format:

      YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]

   where "*" can match any single character.

   警告: This does *not* support parsing arbitrary ISO 8601 strings
     - it is only intended as the inverse operation of
     "datetime.isoformat()". A more full-featured ISO 8601 parser,
     "dateutil.parser.isoparse" is available in the third-party
     package dateutil. This does not support parsing arbitrary ISO
     8601 strings - it is only intended as the inverse operation of
     "datetime.isoformat()".

   示例:

      >>> from datetime import datetime
      >>> datetime.fromisoformat('2011-11-04')
      datetime.datetime(2011, 11, 4, 0, 0)
      >>> datetime.fromisoformat('2011-11-04T00:05:23')
      datetime.datetime(2011, 11, 4, 0, 5, 23)
      >>> datetime.fromisoformat('2011-11-04 00:05:23.283')
      datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)
      >>> datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')
      datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)
      >>> datetime.fromisoformat('2011-11-04T00:05:23+04:00')   
      datetime.datetime(2011, 11, 4, 0, 5, 23,
          tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))

   3.7 新版功能.

classmethod datetime.fromisocalendar(year, week, day)

   Return a "datetime" corresponding to the ISO calendar date
   specified by year, week and day. The non-date components of the
   datetime are populated with their normal default values. This is
   the inverse of the function "datetime.isocalendar()".

   3.8 新版功能.

classmethod datetime.strptime(date_string, format)

   Return a "datetime" corresponding to *date_string*, parsed
   according to *format*.

   这相当于:

      datetime(*(time.strptime(date_string, format)[0:6]))

   "ValueError" is raised if the date_string and format can't be
   parsed by "time.strptime()" or if it returns a value which isn't a
   time tuple. For a complete list of formatting directives, see
   strftime() 和 strptime() 的行为.

类属性：

datetime.min

   最早的可表示 "datetime"，"datetime(MINYEAR, 1, 1, tzinfo=None)"。

datetime.max

   最晚的可表示 "datetime"，"datetime(MAXYEAR, 12, 31, 23, 59, 59,
   999999, tzinfo=None)"。

datetime.resolution

   两个不相等的 "datetime" 对象之间可能的最小间隔，
   "timedelta(microseconds=1)"。

实例属性（只读）：

datetime.year

   在 "MINYEAR" 和 "MAXYEAR" 之间，包含边界。

datetime.month

   1 至 12（含）

datetime.day

   返回1到指定年月的天数间的数字。

datetime.hour

   取值范围是 "range(24)"。

datetime.minute

   取值范围是 "range(60)"。

datetime.second

   取值范围是 "range(60)"。

datetime.microsecond

   取值范围是 "range(1000000)"。

datetime.tzinfo

   作为 *tzinfo* 参数被传给 "datetime" 构造器的对象，如果没有传入值则
   为 "None"。

datetime.fold

   In "[0, 1]". Used to disambiguate wall times during a repeated
   interval. (A repeated interval occurs when clocks are rolled back
   at the end of daylight saving time or when the UTC offset for the
   current zone is decreased for political reasons.) The value 0 (1)
   represents the earlier (later) of the two moments with the same
   wall time representation.

   3.6 新版功能.

支持的运算：

+-----------------------------------------+----------------------------------+
| 运算                                    | 结果                             |
|=========================================|==================================|
| "datetime2 = datetime1 + timedelta"     | (1)                              |
+-----------------------------------------+----------------------------------+
| "datetime2 = datetime1 - timedelta"     | (2)                              |
+-----------------------------------------+----------------------------------+
| "timedelta = datetime1 - datetime2"     | (3)                              |
+-----------------------------------------+----------------------------------+
| "datetime1 < datetime2"                 | 比较 "datetime" 与 "datetime"。  |
|                                         | (4)                              |
+-----------------------------------------+----------------------------------+

1. datetime2 is a duration of timedelta removed from datetime1,
   moving forward in time if "timedelta.days" > 0, or backward if
   "timedelta.days" < 0. The result has the same "tzinfo" attribute as
   the input datetime, and datetime2 - datetime1 == timedelta after.
   "OverflowError" is raised if datetime2.year would be smaller than
   "MINYEAR" or larger than "MAXYEAR". Note that no time zone
   adjustments are done even if the input is an aware object.

2. 计算 datetime2 使得 datetime2 + timedelta == datetime1。 与相加
   操作 一样，结果具有与输入的 datetime 相同的 "tzinfo" 属性，即使输入
   的是 一个感知型对象，该方法也不会进行时区调整。

3. Subtraction of a "datetime" from a "datetime" is defined only if
   both operands are naive, or if both are aware. If one is aware and
   the other is naive, "TypeError" is raised.

   If both are naive, or both are aware and have the same "tzinfo"
   attribute, the "tzinfo" attributes are ignored, and the result is a
   "timedelta" object *t* such that "datetime2 + t == datetime1". No
   time zone adjustments are done in this case.

   If both are aware and have different "tzinfo" attributes, "a-b"
   acts as if *a* and *b* were first converted to naive UTC datetimes
   first. The result is "(a.replace(tzinfo=None) - a.utcoffset()) -
   (b.replace(tzinfo=None) - b.utcoffset())" except that the
   implementation never overflows.

4. 当 *datetime1* 的时间在 *datetime2* 之前则认为 *datetime1* 小于
   *datetime2*。

   If one comparand is naive and the other is aware, "TypeError" is
   raised if an order comparison is attempted. For equality
   comparisons, naive instances are never equal to aware instances.

   If both comparands are aware, and have the same "tzinfo" attribute,
   the common "tzinfo" attribute is ignored and the base datetimes are
   compared. If both comparands are aware and have different "tzinfo"
   attributes, the comparands are first adjusted by subtracting their
   UTC offsets (obtained from "self.utcoffset()").

   在 3.3 版更改: Equality comparisons between aware and naive
   "datetime" instances don't raise "TypeError".

   注解: In order to stop comparison from falling back to the
     default scheme of comparing object addresses, datetime comparison
     normally raises "TypeError" if the other comparand isn't also a
     "datetime" object. However, "NotImplemented" is returned instead
     if the other comparand has a "timetuple()" attribute. This hook
     gives other kinds of date objects a chance at implementing mixed-
     type comparison. If not, when a "datetime" object is compared to
     an object of a different type, "TypeError" is raised unless the
     comparison is "==" or "!=". The latter cases return "False" or
     "True", respectively.

实例方法：

datetime.date()

   返回具有同样 year, month 和 day 值的 "date" 对象。

datetime.time()

   Return "time" object with same hour, minute, second, microsecond
   and fold. "tzinfo" is "None". See also method "timetz()".

   在 3.6 版更改: fold 值会被复制给返回的 "time" 对象。

datetime.timetz()

   Return "time" object with same hour, minute, second, microsecond,
   fold, and tzinfo attributes. See also method "time()".

   在 3.6 版更改: fold 值会被复制给返回的 "time" 对象。

datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)

   Return a datetime with the same attributes, except for those
   attributes given new values by whichever keyword arguments are
   specified. Note that "tzinfo=None" can be specified to create a
   naive datetime from an aware datetime with no conversion of date
   and time data.

   3.6 新版功能: 增加了 "fold" 参数。

datetime.astimezone(tz=None)

   返回一个具有新的 "tzinfo" 属性 *tz* 的 "datetime" 对象，并会调整日
   期和时间数据使得结果对应的 UTC 时间与 *self* 相同，但为 *tz* 时区的
   本地时间。

   If provided, *tz* must be an instance of a "tzinfo" subclass, and
   its "utcoffset()" and "dst()" methods must not return "None". If
   *self* is naive, it is presumed to represent time in the system
   timezone.

   If called without arguments (or with "tz=None") the system local
   timezone is assumed for the target timezone. The ".tzinfo"
   attribute of the converted datetime instance will be set to an
   instance of "timezone" with the zone name and offset obtained from
   the OS.

   如果 "self.tzinfo" 为 *tz*，"self.astimezone(tz)" 等于 *self*: 不会
   对日期或时间数据进行调整。 否则结果为 *tz* 时区的本地时间，代表的
   UTC 时间与 *self* 相同：在 "astz = dt.astimezone(tz)" 之后，"astz -
   astz.utcoffset()" 将具有与 "dt - dt.utcoffset()" 相同的日期和时间数
   据。

   If you merely want to attach a time zone object *tz* to a datetime
   *dt* without adjustment of date and time data, use
   "dt.replace(tzinfo=tz)". If you merely want to remove the time zone
   object from an aware datetime *dt* without conversion of date and
   time data, use "dt.replace(tzinfo=None)".

   请注意默认的 "tzinfo.fromutc()" 方法在 "tzinfo" 的子类中可以被重载
   ，从而影响 "astimezone()" 的返回结果。 如果忽略出错的情况，
   "astimezone()" 的行为就类似于:

      def astimezone(self, tz):
          if self.tzinfo is tz:
              return self
          # Convert self to UTC, and attach the new time zone object.
          utc = (self - self.utcoffset()).replace(tzinfo=tz)
          # Convert from UTC to tz's local time.
          return tz.fromutc(utc)

   在 3.3 版更改: *tz* 现在可以被省略。

   在 3.6 版更改: "astimezone()" 方法可以由无知型实例调用，这将假定其
   表示本地时间。

datetime.utcoffset()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.utcoffset(self)"，并且在后者不返回 "None" 或者一个幅度
   小于一天的 "timedelta" 对象时将引发异常。

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

datetime.dst()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.dst(self)"，并且在后者不返回 "None" 或者一个幅度小于一
   天的 "timedelta" 对象时将引发异常。

   在 3.7 版更改: DST 差值不再限制为一个整数分钟值。

datetime.tzname()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.tzname(self)"，如果后者不返回 "None" 或者一个字符串对
   象则将引发异常。

datetime.timetuple()

   Return a "time.struct_time" such as returned by "time.localtime()".

   "d.timetuple()" is equivalent to:

      time.struct_time((d.year, d.month, d.day,
                        d.hour, d.minute, d.second,
                        d.weekday(), yday, dst))

   where "yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1"
   is the day number within the current year starting with "1" for
   January 1st. The "tm_isdst" flag of the result is set according to
   the "dst()" method: "tzinfo" is "None" or "dst()" returns "None",
   "tm_isdst" is set to "-1"; else if "dst()" returns a non-zero
   value, "tm_isdst" is set to "1"; else "tm_isdst" is set to "0".

datetime.utctimetuple()

   If "datetime" instance *d* is naive, this is the same as
   "d.timetuple()" except that "tm_isdst" is forced to 0 regardless of
   what "d.dst()" returns. DST is never in effect for a UTC time.

   If *d* is aware, *d* is normalized to UTC time, by subtracting
   "d.utcoffset()", and a "time.struct_time" for the normalized time
   is returned. "tm_isdst" is forced to 0. Note that an
   "OverflowError" may be raised if *d*.year was "MINYEAR" or
   "MAXYEAR" and UTC adjustment spills over a year boundary.

   警告: Because naive "datetime" objects are treated by many
     "datetime" methods as local times, it is preferred to use aware
     datetimes to represent times in UTC; as a result, using
     "utcfromtimetuple" may give misleading results. If you have a
     naive "datetime" representing UTC, use
     "datetime.replace(tzinfo=timezone.utc)" to make it aware, at
     which point you can use "datetime.timetuple()".

datetime.toordinal()

   Return the proleptic Gregorian ordinal of the date. The same as
   "self.date().toordinal()".

datetime.timestamp()

   Return POSIX timestamp corresponding to the "datetime" instance.
   The return value is a "float" similar to that returned by
   "time.time()".

   Naive "datetime" instances are assumed to represent local time and
   this method relies on the platform C "mktime()" function to perform
   the conversion. Since "datetime" supports wider range of values
   than "mktime()" on many platforms, this method may raise
   "OverflowError" for times far in the past or far in the future.

   对于感知型 "datetime" 实例，返回值的计算方式为:

      (dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()

   3.3 新版功能.

   在 3.6 版更改: "timestamp()" 方法使用 "fold" 属性来消除重复间隔中的
   时间歧义。

   注解: There is no method to obtain the POSIX timestamp directly
     from a naive "datetime" instance representing UTC time. If your
     application uses this convention and your system timezone is not
     set to UTC, you can obtain the POSIX timestamp by supplying
     "tzinfo=timezone.utc":

        timestamp = dt.replace(tzinfo=timezone.utc).timestamp()

     或者通过直接计算时间戳:

        timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)

datetime.weekday()

   返回一个整数代表星期几，星期一为 0，星期天为 6。 相当于
   "self.date().weekday()"。 另请参阅 "isoweekday()"。

datetime.isoweekday()

   返回一个整数代表星期几，星期一为 1，星期天为 7。 相当于
   "self.date().isoweekday()"。 另请参阅 "weekday()", "isocalendar()"
   。

datetime.isocalendar()

   Return a 3-tuple, (ISO year, ISO week number, ISO weekday). The
   same as "self.date().isocalendar()".

datetime.isoformat(sep='T', timespec='auto')

   Return a string representing the date and time in ISO 8601 format:

   * "YYYY-MM-DDTHH:MM:SS.ffffff", if "microsecond" is not 0

   * "YYYY-MM-DDTHH:MM:SS", if "microsecond" is 0

   If "utcoffset()" does not return "None", a string is appended,
   giving the UTC offset:

   * "YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]", if
     "microsecond" is not 0

   * "YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]",  if "microsecond" is
     0

   示例:

      >>> from datetime import datetime, timezone
      >>> datetime(2019, 5, 18, 15, 17, 8, 132263).isoformat()
      '2019-05-18T15:17:08.132263'
      >>> datetime(2019, 5, 18, 15, 17, tzinfo=timezone.utc).isoformat()
      '2019-05-18T15:17:00+00:00'

   The optional argument *sep* (default "'T'") is a one-character
   separator, placed between the date and time portions of the result.
   For example:

      >>> from datetime import tzinfo, timedelta, datetime
      >>> class TZ(tzinfo):
      ...     """A time zone with an arbitrary, constant -06:39 offset."""
      ...     def utcoffset(self, dt):
      ...         return timedelta(hours=-6, minutes=-39)
      ...
      >>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')
      '2002-12-25 00:00:00-06:39'
      >>> datetime(2009, 11, 27, microsecond=100, tzinfo=TZ()).isoformat()
      '2009-11-27T00:00:00.000100-06:39'

   可选参数 *timespec* 要包含的额外时间组件值 (默认为 "'auto'")。它可
   以是以下值之一：

   * "'auto'": 如果 "microsecond" 为 0 则与 "'seconds'" 相同，否则与
     "'microseconds'" 相同。

   * "'hours'": Include the "hour" in the two-digit "HH" format.

   * "'minutes'": Include "hour" and "minute" in "HH:MM" format.

   * "'seconds'": Include "hour", "minute", and "second" in
     "HH:MM:SS" format.

   * "'milliseconds'": Include full time, but truncate fractional
     second part to milliseconds. "HH:MM:SS.sss" format.

   * "'microseconds'": Include full time in "HH:MM:SS.ffffff"
     format.

   注解: 排除掉的时间部分将被截断，而不是被舍入。

   "ValueError" will be raised on an invalid *timespec* argument:

      >>> from datetime import datetime
      >>> datetime.now().isoformat(timespec='minutes')   
      '2002-12-25T00:00'
      >>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)
      >>> dt.isoformat(timespec='microseconds')
      '2015-01-01T12:30:59.000000'

   3.6 新版功能: 增加了 *timespec* 参数。

datetime.__str__()

   对于 "datetime" 实例 *d*，"str(d)" 等价于 "d.isoformat(' ')"。

datetime.ctime()

   Return a string representing the date and time:

      >>> from datetime import datetime
      >>> datetime(2002, 12, 4, 20, 30, 40).ctime()
      'Wed Dec  4 20:30:40 2002'

   The output string will *not* include time zone information,
   regardless of whether the input is aware or naive.

   "d.ctime()" 等效于:

      time.ctime(time.mktime(d.timetuple()))

   on platforms where the native C "ctime()" function (which
   "time.ctime()" invokes, but which "datetime.ctime()" does not
   invoke) conforms to the C standard.

datetime.strftime(format)

   Return a string representing the date and time, controlled by an
   explicit format string. For a complete list of formatting
   directives, see strftime() 和 strptime() 的行为.

datetime.__format__(format)

   Same as "datetime.strftime()". This makes it possible to specify a
   format string for a "datetime" object in formatted string literals
   and when using "str.format()". For a complete list of formatting
   directives, see strftime() 和 strptime() 的行为.


Examples of Usage: "datetime"
-----------------------------

Examples of working with "datetime" objects:

   >>> from datetime import datetime, date, time, timezone

   >>> # Using datetime.combine()
   >>> d = date(2005, 7, 14)
   >>> t = time(12, 30)
   >>> datetime.combine(d, t)
   datetime.datetime(2005, 7, 14, 12, 30)

   >>> # Using datetime.now()
   >>> datetime.now()   
   datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1
   >>> datetime.now(timezone.utc)   
   datetime.datetime(2007, 12, 6, 15, 29, 43, 79060, tzinfo=datetime.timezone.utc)

   >>> # Using datetime.strptime()
   >>> dt = datetime.strptime("21/11/06 16:30", "%d/%m/%y %H:%M")
   >>> dt
   datetime.datetime(2006, 11, 21, 16, 30)

   >>> # Using datetime.timetuple() to get tuple of all attributes
   >>> tt = dt.timetuple()
   >>> for it in tt:   
   ...     print(it)
   ...
   2006    # year
   11      # month
   21      # day
   16      # hour
   30      # minute
   0       # second
   1       # weekday (0 = Monday)
   325     # number of days since 1st January
   -1      # dst - method tzinfo.dst() returned None

   >>> # Date in ISO format
   >>> ic = dt.isocalendar()
   >>> for it in ic:   
   ...     print(it)
   ...
   2006    # ISO year
   47      # ISO week
   2       # ISO weekday

   >>> # Formatting a datetime
   >>> dt.strftime("%A, %d. %B %Y %I:%M%p")
   'Tuesday, 21. November 2006 04:30PM'
   >>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, "day", "month", "time")
   'The day is 21, the month is November, the time is 04:30PM.'

The example below defines a "tzinfo" subclass capturing time zone
information for Kabul, Afghanistan, which used +4 UTC until 1945 and
then +4:30 UTC thereafter:

   from datetime import timedelta, datetime, tzinfo, timezone

   class KabulTz(tzinfo):
       # Kabul used +4 until 1945, when they moved to +4:30
       UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)

       def utcoffset(self, dt):
           if dt.year < 1945:
               return timedelta(hours=4)
           elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, 30):
               # An ambiguous ("imaginary") half-hour range representing
               # a 'fold' in time due to the shift from +4 to +4:30.
               # If dt falls in the imaginary range, use fold to decide how
               # to resolve. See PEP495.
               return timedelta(hours=4, minutes=(30 if dt.fold else 0))
           else:
               return timedelta(hours=4, minutes=30)

       def fromutc(self, dt):
           # Follow same validations as in datetime.tzinfo
           if not isinstance(dt, datetime):
               raise TypeError("fromutc() requires a datetime argument")
           if dt.tzinfo is not self:
               raise ValueError("dt.tzinfo is not self")

           # A custom implementation is required for fromutc as
           # the input to this function is a datetime with utc values
           # but with a tzinfo set to self.
           # See datetime.astimezone or fromtimestamp.
           if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:
               return dt + timedelta(hours=4, minutes=30)
           else:
               return dt + timedelta(hours=4)

       def dst(self, dt):
           # Kabul does not observe daylight saving time.
           return timedelta(0)

       def tzname(self, dt):
           if dt >= self.UTC_MOVE_DATE:
               return "+04:30"
           return "+04"

Usage of "KabulTz" from above:

   >>> tz1 = KabulTz()

   >>> # Datetime before the change
   >>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)
   >>> print(dt1.utcoffset())
   4:00:00

   >>> # Datetime after the change
   >>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)
   >>> print(dt2.utcoffset())
   4:30:00

   >>> # Convert datetime to another time zone
   >>> dt3 = dt2.astimezone(timezone.utc)
   >>> dt3
   datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)
   >>> dt2
   datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())
   >>> dt2 == dt3
   True


"time" 对象
===========

A "time" object represents a (local) time of day, independent of any
particular day, and subject to adjustment via a "tzinfo" object.

class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

   All arguments are optional. *tzinfo* may be "None", or an instance
   of a "tzinfo" subclass. The remaining arguments must be integers in
   the following ranges:

   * "0 <= hour < 24",

   * "0 <= minute < 60",

   * "0 <= second < 60",

   * "0 <= microsecond < 1000000",

   * "fold in [0, 1]".

   If an argument outside those ranges is given, "ValueError" is
   raised. All default to "0" except *tzinfo*, which defaults to
   "None".

类属性：

time.min

   早最的可表示 "time", "time(0, 0, 0, 0)"。

time.max

   最晚的可表示 "time", "time(23, 59, 59, 999999)"。

time.resolution

   两个不相等的 "time" 对象之间可能的最小间隔，
   "timedelta(microseconds=1)"，但是请注意 "time" 对象并不支持算术运算
   。

实例属性（只读）：

time.hour

   取值范围是 "range(24)"。

time.minute

   取值范围是 "range(60)"。

time.second

   取值范围是 "range(60)"。

time.microsecond

   取值范围是 "range(1000000)"。

time.tzinfo

   作为 tzinfo 参数被传给 "time" 构造器的对象，如果没有传入值则为
   "None"。

time.fold

   In "[0, 1]". Used to disambiguate wall times during a repeated
   interval. (A repeated interval occurs when clocks are rolled back
   at the end of daylight saving time or when the UTC offset for the
   current zone is decreased for political reasons.) The value 0 (1)
   represents the earlier (later) of the two moments with the same
   wall time representation.

   3.6 新版功能.

"time" objects support comparison of "time" to "time", where *a* is
considered less than *b* when *a* precedes *b* in time. If one
comparand is naive and the other is aware, "TypeError" is raised if an
order comparison is attempted. For equality comparisons, naive
instances are never equal to aware instances.

If both comparands are aware, and have the same "tzinfo" attribute,
the common "tzinfo" attribute is ignored and the base times are
compared. If both comparands are aware and have different "tzinfo"
attributes, the comparands are first adjusted by subtracting their UTC
offsets (obtained from "self.utcoffset()"). In order to stop mixed-
type comparisons from falling back to the default comparison by object
address, when a "time" object is compared to an object of a different
type, "TypeError" is raised unless the comparison is "==" or "!=". The
latter cases return "False" or "True", respectively.

在 3.3 版更改: Equality comparisons between aware and naive "time"
instances don't raise "TypeError".

In Boolean contexts, a "time" object is always considered to be true.

在 3.5 版更改: Before Python 3.5, a "time" object was considered to be
false if it represented midnight in UTC. This behavior was considered
obscure and error-prone and has been removed in Python 3.5. See
bpo-13936 for full details.

其他构造方法：

classmethod time.fromisoformat(time_string)

   Return a "time" corresponding to a *time_string* in one of the
   formats emitted by "time.isoformat()". Specifically, this function
   supports strings in the format:

      HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]

   警告: This does *not* support parsing arbitrary ISO 8601 strings.
     It is only intended as the inverse operation of
     "time.isoformat()".

   示例:

      >>> from datetime import time
      >>> time.fromisoformat('04:23:01')
      datetime.time(4, 23, 1)
      >>> time.fromisoformat('04:23:01.000384')
      datetime.time(4, 23, 1, 384)
      >>> time.fromisoformat('04:23:01+04:00')
      datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))

   3.7 新版功能.

实例方法：

time.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)

   Return a "time" with the same value, except for those attributes
   given new values by whichever keyword arguments are specified. Note
   that "tzinfo=None" can be specified to create a naive "time" from
   an aware "time", without conversion of the time data.

   3.6 新版功能: 增加了 "fold" 参数。

time.isoformat(timespec='auto')

   Return a string representing the time in ISO 8601 format, one of:

   * "HH:MM:SS.ffffff", if "microsecond" is not 0

   * "HH:MM:SS", if "microsecond" is 0

   * "HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]", if "utcoffset()" does
     not return "None"

   * "HH:MM:SS+HH:MM[:SS[.ffffff]]", if "microsecond" is 0 and
     "utcoffset()" does not return "None"

   可选参数 *timespec* 要包含的额外时间组件值 (默认为 "'auto'")。它可
   以是以下值之一：

   * "'auto'": 如果 "microsecond" 为 0 则与 "'seconds'" 相同，否则与
     "'microseconds'" 相同。

   * "'hours'": Include the "hour" in the two-digit "HH" format.

   * "'minutes'": Include "hour" and "minute" in "HH:MM" format.

   * "'seconds'": Include "hour", "minute", and "second" in
     "HH:MM:SS" format.

   * "'milliseconds'": Include full time, but truncate fractional
     second part to milliseconds. "HH:MM:SS.sss" format.

   * "'microseconds'": Include full time in "HH:MM:SS.ffffff"
     format.

   注解: 排除掉的时间部分将被截断，而不是被舍入。

   对于无效的 *timespec* 参数将引发 "ValueError"。

   示例:

      >>> from datetime import time
      >>> time(hour=12, minute=34, second=56, microsecond=123456).isoformat(timespec='minutes')
      '12:34'
      >>> dt = time(hour=12, minute=34, second=56, microsecond=0)
      >>> dt.isoformat(timespec='microseconds')
      '12:34:56.000000'
      >>> dt.isoformat(timespec='auto')
      '12:34:56'

   3.6 新版功能: 增加了 *timespec* 参数。

time.__str__()

   对于时间对象 *t*, "str(t)" 等价于 "t.isoformat()"。

time.strftime(format)

   Return a string representing the time, controlled by an explicit
   format string. For a complete list of formatting directives, see
   strftime() 和 strptime() 的行为.

time.__format__(format)

   Same as "time.strftime()". This makes it possible to specify a
   format string for a "time" object in formatted string literals and
   when using "str.format()". For a complete list of formatting
   directives, see strftime() 和 strptime() 的行为.

time.utcoffset()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.utcoffset(None)"，并且在后者不返回 "None" 或一个幅度小
   于一天的 a "timedelta" 对象时将引发异常。

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

time.dst()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.dst(None)"，并且在后者不返回 "None" 或者一个幅度小于一
   天的 "timedelta" 对象时将引发异常。

   在 3.7 版更改: DST 差值不再限制为一个整数分钟值。

time.tzname()

   如果 "tzinfo" 为 "None"，则返回 "None"，否则返回
   "self.tzinfo.tzname(None)"，如果后者不返回 "None" 或者一个字符串对
   象则将引发异常。


Examples of Usage: "time"
-------------------------

Examples of working with a "time" object:

   >>> from datetime import time, tzinfo, timedelta
   >>> class TZ1(tzinfo):
   ...     def utcoffset(self, dt):
   ...         return timedelta(hours=1)
   ...     def dst(self, dt):
   ...         return timedelta(0)
   ...     def tzname(self,dt):
   ...         return "+01:00"
   ...     def  __repr__(self):
   ...         return f"{self.__class__.__name__}()"
   ...
   >>> t = time(12, 10, 30, tzinfo=TZ1())
   >>> t
   datetime.time(12, 10, 30, tzinfo=TZ1())
   >>> t.isoformat()
   '12:10:30+01:00'
   >>> t.dst()
   datetime.timedelta(0)
   >>> t.tzname()
   '+01:00'
   >>> t.strftime("%H:%M:%S %Z")
   '12:10:30 +01:00'
   >>> 'The {} is {:%H:%M}.'.format("time", t)
   'The time is 12:10.'


"tzinfo" 对象
=============

class datetime.tzinfo

   This is an abstract base class, meaning that this class should not
   be instantiated directly.  Define a subclass of "tzinfo" to capture
   information about a particular time zone.

   "tzinfo" 的（某个实体子类）的实例可以被传给 "datetime" 和 "time" 对
   象的构造器。 这些对象会将它们的属性视为对应于本地时间，并且
   "tzinfo" 对象支持展示本地时间与 UTC 的差值、时区名称以及 DST 差值的
   方法，都是与传给它们的日期或时间对象的相对值。

   You need to derive a concrete subclass, and (at least) supply
   implementations of the standard "tzinfo" methods needed by the
   "datetime" methods you use. The "datetime" module provides
   "timezone", a simple concrete subclass of "tzinfo" which can
   represent timezones with fixed offset from UTC such as UTC itself
   or North American EST and EDT.

   Special requirement for pickling:  A "tzinfo" subclass must have an
   "__init__()" method that can be called with no arguments, otherwise
   it can be pickled but possibly not unpickled again. This is a
   technical requirement that may be relaxed in the future.

   A concrete subclass of "tzinfo" may need to implement the following
   methods. Exactly which methods are needed depends on the uses made
   of aware "datetime" objects. If in doubt, simply implement all of
   them.

tzinfo.utcoffset(dt)

   Return offset of local time from UTC, as a "timedelta" object that
   is positive east of UTC. If local time is west of UTC, this should
   be negative.

   This represents the *total* offset from UTC; for example, if a
   "tzinfo" object represents both time zone and DST adjustments,
   "utcoffset()" should return their sum. If the UTC offset isn't
   known, return "None". Else the value returned must be a "timedelta"
   object strictly between "-timedelta(hours=24)" and
   "timedelta(hours=24)" (the magnitude of the offset must be less
   than one day). Most implementations of "utcoffset()" will probably
   look like one of these two:

      return CONSTANT                 # fixed-offset class
      return CONSTANT + self.dst(dt)  # daylight-aware class

   如果 "utcoffset()" 返回值不为 "None"，则 "dst()" 也不应返回 "None"
   。

   默认的 "utcoffset()" 实现会引发 "NotImplementedError"。

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

tzinfo.dst(dt)

   Return the daylight saving time (DST) adjustment, as a "timedelta"
   object or "None" if DST information isn't known.

   Return "timedelta(0)" if DST is not in effect. If DST is in effect,
   return the offset as a "timedelta" object (see "utcoffset()" for
   details). Note that DST offset, if applicable, has already been
   added to the UTC offset returned by "utcoffset()", so there's no
   need to consult "dst()" unless you're interested in obtaining DST
   info separately. For example, "datetime.timetuple()" calls its
   "tzinfo" attribute's "dst()" method to determine how the "tm_isdst"
   flag should be set, and "tzinfo.fromutc()" calls "dst()" to account
   for DST changes when crossing time zones.

   一个可以同时处理标准时和夏令时的 "tzinfo" 子类的实例 *tz* 必须在此
   情形中保持一致：

   "tz.utcoffset(dt) - tz.dst(dt)"

   must return the same result for every "datetime" *dt* with
   "dt.tzinfo == tz"  For sane "tzinfo" subclasses, this expression
   yields the time zone's "standard offset", which should not depend
   on the date or the time, but only on geographic location. The
   implementation of "datetime.astimezone()" relies on this, but
   cannot detect violations; it's the programmer's responsibility to
   ensure it. If a "tzinfo" subclass cannot guarantee this, it may be
   able to override the default implementation of "tzinfo.fromutc()"
   to work correctly with "astimezone()" regardless.

   大多数 "dst()" 的实现可能会如以下两者之一:

      def dst(self, dt):
          # a fixed-offset class:  doesn't account for DST
          return timedelta(0)

   或者：

      def dst(self, dt):
          # Code to set dston and dstoff to the time zone's DST
          # transition times based on the input dt.year, and expressed
          # in standard local time.

          if dston <= dt.replace(tzinfo=None) < dstoff:
              return timedelta(hours=1)
          else:
              return timedelta(0)

   默认的 "dst()" 实现会引发 "NotImplementedError"。

   在 3.7 版更改: DST 差值不再限制为一个整数分钟值。

tzinfo.tzname(dt)

   Return the time zone name corresponding to the "datetime" object
   *dt*, as a string. Nothing about string names is defined by the
   "datetime" module, and there's no requirement that it mean anything
   in particular. For example, "GMT", "UTC", "-500", "-5:00", "EDT",
   "US/Eastern", "America/New York" are all valid replies. Return
   "None" if a string name isn't known. Note that this is a method
   rather than a fixed string primarily because some "tzinfo"
   subclasses will wish to return different names depending on the
   specific value of *dt* passed, especially if the "tzinfo" class is
   accounting for daylight time.

   默认的 "tzname()" 实现会引发 "NotImplementedError"。

These methods are called by a "datetime" or "time" object, in response
to their methods of the same names. A "datetime" object passes itself
as the argument, and a "time" object passes "None" as the argument. A
"tzinfo" subclass's methods should therefore be prepared to accept a
*dt* argument of "None", or of class "datetime".

When "None" is passed, it's up to the class designer to decide the
best response. For example, returning "None" is appropriate if the
class wishes to say that time objects don't participate in the
"tzinfo" protocols. It may be more useful for "utcoffset(None)" to
return the standard UTC offset, as there is no other convention for
discovering the standard offset.

When a "datetime" object is passed in response to a "datetime" method,
"dt.tzinfo" is the same object as *self*. "tzinfo" methods can rely on
this, unless user code calls "tzinfo" methods directly. The intent is
that the "tzinfo" methods interpret *dt* as being in local time, and
not need worry about objects in other timezones.

还有一个额外的 "tzinfo" 方法，某个子类可能会希望重载它：

tzinfo.fromutc(dt)

   This is called from the default "datetime.astimezone()"
   implementation. When called from that, "dt.tzinfo" is *self*, and
   *dt*'s date and time data are to be viewed as expressing a UTC
   time. The purpose of "fromutc()" is to adjust the date and time
   data, returning an equivalent datetime in *self*'s local time.

   Most "tzinfo" subclasses should be able to inherit the default
   "fromutc()" implementation without problems. It's strong enough to
   handle fixed-offset time zones, and time zones accounting for both
   standard and daylight time, and the latter even if the DST
   transition times differ in different years. An example of a time
   zone the default "fromutc()" implementation may not handle
   correctly in all cases is one where the standard offset (from UTC)
   depends on the specific date and time passed, which can happen for
   political reasons. The default implementations of "astimezone()"
   and "fromutc()" may not produce the result you want if the result
   is one of the hours straddling the moment the standard offset
   changes.

   忽略针对错误情况的代码，默认 "fromutc()" 实现的行为方式如下:

      def fromutc(self, dt):
          # raise ValueError error if dt.tzinfo is not self
          dtoff = dt.utcoffset()
          dtdst = dt.dst()
          # raise ValueError if dtoff is None or dtdst is None
          delta = dtoff - dtdst  # this is self's standard offset
          if delta:
              dt += delta   # convert to standard local time
              dtdst = dt.dst()
              # raise ValueError if dtdst is None
          if dtdst:
              return dt + dtdst
          else:
              return dt

在以下 "tzinfo_examples.py" 文件中有一些 "tzinfo" 类的例子：

   from datetime import tzinfo, timedelta, datetime

   ZERO = timedelta(0)
   HOUR = timedelta(hours=1)
   SECOND = timedelta(seconds=1)

   # A class capturing the platform's idea of local time.
   # (May result in wrong values on historical times in
   #  timezones where UTC offset and/or the DST rules had
   #  changed in the past.)
   import time as _time

   STDOFFSET = timedelta(seconds = -_time.timezone)
   if _time.daylight:
       DSTOFFSET = timedelta(seconds = -_time.altzone)
   else:
       DSTOFFSET = STDOFFSET

   DSTDIFF = DSTOFFSET - STDOFFSET

   class LocalTimezone(tzinfo):

       def fromutc(self, dt):
           assert dt.tzinfo is self
           stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND
           args = _time.localtime(stamp)[:6]
           dst_diff = DSTDIFF // SECOND
           # Detect fold
           fold = (args == _time.localtime(stamp - dst_diff))
           return datetime(*args, microsecond=dt.microsecond,
                           tzinfo=self, fold=fold)

       def utcoffset(self, dt):
           if self._isdst(dt):
               return DSTOFFSET
           else:
               return STDOFFSET

       def dst(self, dt):
           if self._isdst(dt):
               return DSTDIFF
           else:
               return ZERO

       def tzname(self, dt):
           return _time.tzname[self._isdst(dt)]

       def _isdst(self, dt):
           tt = (dt.year, dt.month, dt.day,
                 dt.hour, dt.minute, dt.second,
                 dt.weekday(), 0, 0)
           stamp = _time.mktime(tt)
           tt = _time.localtime(stamp)
           return tt.tm_isdst > 0

   Local = LocalTimezone()


   # A complete implementation of current DST rules for major US time zones.

   def first_sunday_on_or_after(dt):
       days_to_go = 6 - dt.weekday()
       if days_to_go:
           dt += timedelta(days_to_go)
       return dt


   # US DST Rules
   #
   # This is a simplified (i.e., wrong for a few cases) set of rules for US
   # DST start and end times. For a complete and up-to-date set of DST rules
   # and timezone definitions, visit the Olson Database (or try pytz):
   # http://www.twinsun.com/tz/tz-link.htm
   # http://sourceforge.net/projects/pytz/ (might not be up-to-date)
   #
   # In the US, since 2007, DST starts at 2am (standard time) on the second
   # Sunday in March, which is the first Sunday on or after Mar 8.
   DSTSTART_2007 = datetime(1, 3, 8, 2)
   # and ends at 2am (DST time) on the first Sunday of Nov.
   DSTEND_2007 = datetime(1, 11, 1, 2)
   # From 1987 to 2006, DST used to start at 2am (standard time) on the first
   # Sunday in April and to end at 2am (DST time) on the last
   # Sunday of October, which is the first Sunday on or after Oct 25.
   DSTSTART_1987_2006 = datetime(1, 4, 1, 2)
   DSTEND_1987_2006 = datetime(1, 10, 25, 2)
   # From 1967 to 1986, DST used to start at 2am (standard time) on the last
   # Sunday in April (the one on or after April 24) and to end at 2am (DST time)
   # on the last Sunday of October, which is the first Sunday
   # on or after Oct 25.
   DSTSTART_1967_1986 = datetime(1, 4, 24, 2)
   DSTEND_1967_1986 = DSTEND_1987_2006

   def us_dst_range(year):
       # Find start and end times for US DST. For years before 1967, return
       # start = end for no DST.
       if 2006 < year:
           dststart, dstend = DSTSTART_2007, DSTEND_2007
       elif 1986 < year < 2007:
           dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006
       elif 1966 < year < 1987:
           dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986
       else:
           return (datetime(year, 1, 1), ) * 2

       start = first_sunday_on_or_after(dststart.replace(year=year))
       end = first_sunday_on_or_after(dstend.replace(year=year))
       return start, end


   class USTimeZone(tzinfo):

       def __init__(self, hours, reprname, stdname, dstname):
           self.stdoffset = timedelta(hours=hours)
           self.reprname = reprname
           self.stdname = stdname
           self.dstname = dstname

       def __repr__(self):
           return self.reprname

       def tzname(self, dt):
           if self.dst(dt):
               return self.dstname
           else:
               return self.stdname

       def utcoffset(self, dt):
           return self.stdoffset + self.dst(dt)

       def dst(self, dt):
           if dt is None or dt.tzinfo is None:
               # An exception may be sensible here, in one or both cases.
               # It depends on how you want to treat them.  The default
               # fromutc() implementation (called by the default astimezone()
               # implementation) passes a datetime with dt.tzinfo is self.
               return ZERO
           assert dt.tzinfo is self
           start, end = us_dst_range(dt.year)
           # Can't compare naive to aware objects, so strip the timezone from
           # dt first.
           dt = dt.replace(tzinfo=None)
           if start + HOUR <= dt < end - HOUR:
               # DST is in effect.
               return HOUR
           if end - HOUR <= dt < end:
               # Fold (an ambiguous hour): use dt.fold to disambiguate.
               return ZERO if dt.fold else HOUR
           if start <= dt < start + HOUR:
               # Gap (a non-existent hour): reverse the fold rule.
               return HOUR if dt.fold else ZERO
           # DST is off.
           return ZERO

       def fromutc(self, dt):
           assert dt.tzinfo is self
           start, end = us_dst_range(dt.year)
           start = start.replace(tzinfo=self)
           end = end.replace(tzinfo=self)
           std_time = dt + self.stdoffset
           dst_time = std_time + HOUR
           if end <= dst_time < end + HOUR:
               # Repeated hour
               return std_time.replace(fold=1)
           if std_time < start or dst_time >= end:
               # Standard time
               return std_time
           if start <= std_time < end - HOUR:
               # Daylight saving time
               return dst_time


   Eastern  = USTimeZone(-5, "Eastern",  "EST", "EDT")
   Central  = USTimeZone(-6, "Central",  "CST", "CDT")
   Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
   Pacific  = USTimeZone(-8, "Pacific",  "PST", "PDT")

Note that there are unavoidable subtleties twice per year in a
"tzinfo" subclass accounting for both standard and daylight time, at
the DST transition points. For concreteness, consider US Eastern (UTC
-0500), where EDT begins the minute after 1:59 (EST) on the second
Sunday in March, and ends the minute after 1:59 (EDT) on the first
Sunday in November:

     UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
     EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
     EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM

   start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM

     end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM

When DST starts (the "start" line), the local wall clock leaps from
1:59 to 3:00. A wall time of the form 2:MM doesn't really make sense
on that day, so "astimezone(Eastern)" won't deliver a result with
"hour == 2" on the day DST begins. For example, at the Spring forward
transition of 2016, we get:

   >>> from datetime import datetime, timezone
   >>> from tzinfo_examples import HOUR, Eastern
   >>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)
   >>> for i in range(4):
   ...     u = u0 + i*HOUR
   ...     t = u.astimezone(Eastern)
   ...     print(u.time(), 'UTC =', t.time(), t.tzname())
   ...
   05:00:00 UTC = 00:00:00 EST
   06:00:00 UTC = 01:00:00 EST
   07:00:00 UTC = 03:00:00 EDT
   08:00:00 UTC = 04:00:00 EDT

When DST ends (the "end" line), there's a potentially worse problem:
there's an hour that can't be spelled unambiguously in local wall
time: the last hour of daylight time. In Eastern, that's times of the
form 5:MM UTC on the day daylight time ends. The local wall clock
leaps from 1:59 (daylight time) back to 1:00 (standard time) again.
Local times of the form 1:MM are ambiguous. "astimezone()" mimics the
local clock's behavior by mapping two adjacent UTC hours into the same
local hour then. In the Eastern example, UTC times of the form 5:MM
and 6:MM both map to 1:MM when converted to Eastern, but earlier times
have the "fold" attribute set to 0 and the later times have it set to
1. For example, at the Fall back transition of 2016, we get:

   >>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)
   >>> for i in range(4):
   ...     u = u0 + i*HOUR
   ...     t = u.astimezone(Eastern)
   ...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)
   ...
   04:00:00 UTC = 00:00:00 EDT 0
   05:00:00 UTC = 01:00:00 EDT 0
   06:00:00 UTC = 01:00:00 EST 1
   07:00:00 UTC = 02:00:00 EST 0

Note that the "datetime" instances that differ only by the value of
the "fold" attribute are considered equal in comparisons.

不允许时间显示存在歧义的应用需要显式地检查 "fold" 属性的值，或者避免使
用混合式的 "tzinfo" 子类；当使用 "timezone" 或者任何其他固定差值的
"tzinfo" 子类例如仅表示 EST（固定差值 -5 小时）或仅表示 EDT（固定差值
-4 小时）的类时是不会有歧义的。

参见:

  dateutil.tz
     The "datetime" module has a basic "timezone" class (for handling
     arbitrary fixed offsets from UTC) and its "timezone.utc"
     attribute (a UTC timezone instance).

     *dateutil.tz* library brings the *IANA timezone database* (also
     known as the Olson database) to Python, and its usage is
     recommended.

  IANA 时区数据库
     该时区数据库 (通常称为 tz, tzdata 或 zoneinfo) 包含大量代码和数据
     用来表示全球许多有代表性的地点的本地时间的历史信息。 它会定期进行
     更新以反映各政治实体对时区边界、UTC 差值和夏令时规则的更改。


"timezone" 对象
===============

The "timezone" class is a subclass of "tzinfo", each instance of which
represents a timezone defined by a fixed offset from UTC.

Objects of this class cannot be used to represent timezone information
in the locations where different offsets are used in different days of
the year or where historical changes have been made to civil time.

class datetime.timezone(offset, name=None)

   The *offset* argument must be specified as a "timedelta" object
   representing the difference between the local time and UTC. It must
   be strictly between "-timedelta(hours=24)" and
   "timedelta(hours=24)", otherwise "ValueError" is raised.

   The *name* argument is optional. If specified it must be a string
   that will be used as the value returned by the "datetime.tzname()"
   method.

   3.2 新版功能.

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

timezone.utcoffset(dt)

   Return the fixed value specified when the "timezone" instance is
   constructed.

   The *dt* argument is ignored. The return value is a "timedelta"
   instance equal to the difference between the local time and UTC.

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

timezone.tzname(dt)

   Return the fixed value specified when the "timezone" instance is
   constructed.

   If *name* is not provided in the constructor, the name returned by
   "tzname(dt)" is generated from the value of the "offset" as
   follows. If *offset* is "timedelta(0)", the name is "UTC",
   otherwise it is a string in the format "UTC±HH:MM", where ± is the
   sign of "offset", HH and MM are two digits of "offset.hours" and
   "offset.minutes" respectively.

   在 3.6 版更改: Name generated from "offset=timedelta(0)" is now
   plain *'UTC'*, not "'UTC+00:00'".

timezone.dst(dt)

   总是返回 "None"。

timezone.fromutc(dt)

   Return "dt + offset". The *dt* argument must be an aware "datetime"
   instance, with "tzinfo" set to "self".

类属性：

timezone.utc

   UTC 时区，"timezone(timedelta(0))"。


"strftime()" 和 "strptime()" 的行为
===================================

"date", "datetime", and "time" objects all support a
"strftime(format)" method, to create a string representing the time
under the control of an explicit format string.

Conversely, the "datetime.strptime()" class method creates a
"datetime" object from a string representing a date and time and a
corresponding format string.

The table below provides a high-level comparison of "strftime()"
versus "strptime()":

+------------------+----------------------------------------------------------+--------------------------------------------------------------------------------+
|                  | "strftime"                                               | "strptime"                                                                     |
|==================|==========================================================|================================================================================|
| 用法             | 根据给定的格式将对象转换为字符串                         | 将字符串解析为给定相应格式的 "datetime" 对象                                   |
+------------------+----------------------------------------------------------+--------------------------------------------------------------------------------+
| 方法类型         | 实例方法                                                 | 类方法                                                                         |
+------------------+----------------------------------------------------------+--------------------------------------------------------------------------------+
| 方法             | "date"; "datetime"; "time"                               | "datetime"                                                                     |
+------------------+----------------------------------------------------------+--------------------------------------------------------------------------------+
| 签名             | "strftime(format)"                                       | "strptime(date_string, format)"                                                |
+------------------+----------------------------------------------------------+--------------------------------------------------------------------------------+


"strftime()" 和 "strptime()" Format Codes
-----------------------------------------

The following is a list of all the format codes that the 1989 C
standard requires, and these work on all platforms with a standard C
implementation.

+-------------+----------------------------------+--------------------------+---------+
| 指令        | 意义                             | 示例                     | 注释    |
|=============|==================================|==========================|=========|
| "%a"        | 当地工作日的缩写。               | Sun, Mon, ..., Sat       | (1)     |
|             |                                  | (en_US); So, Mo, ..., Sa |         |
|             |                                  | (de_DE)                  |         |
+-------------+----------------------------------+--------------------------+---------+
| "%A"        | 本地化的星期中每日的完整名称。   | Sunday, Monday, ...,     | (1)     |
|             |                                  | Saturday (en_US);        |         |
|             |                                  | Sonntag, Montag, ...,    |         |
|             |                                  | Samstag (de_DE)          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%w"        | 以十进制数显示的工作日，其中0表  | 0, 1, ..., 6             |         |
|             | 示星期日，6表示星期六。          |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%d"        | 补零后，以十进制数显示的月份中的 | 01, 02, ..., 31          | (9)     |
|             | 一天。                           |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%b"        | 当地月份的缩写。                 | Jan, Feb, ..., Dec       | (1)     |
|             |                                  | (en_US); Jan, Feb, ...,  |         |
|             |                                  | Dez (de_DE)              |         |
+-------------+----------------------------------+--------------------------+---------+
| "%B"        | 本地化的月份全名。               | January, February, ...,  | (1)     |
|             |                                  | December (en_US);        |         |
|             |                                  | Januar, Februar, ...,    |         |
|             |                                  | Dezember (de_DE)         |         |
+-------------+----------------------------------+--------------------------+---------+
| "%m"        | 补零后，以十进制数显示的月份。   | 01, 02, ..., 12          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%y"        | 补零后，以十进制数表示的，不带世 | 00, 01, ..., 99          | (9)     |
|             | 纪的年份。                       |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%Y"        | 十进制数表示的带世纪的年份。     | 0001, 0002, ..., 2013,   | (2)     |
|             |                                  | 2014, ..., 9998, 9999    |         |
+-------------+----------------------------------+--------------------------+---------+
| "%H"        | 以补零后的十进制数表示的小时（24 | 00, 01, ..., 23          | (9)     |
|             | 小时制）。                       |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%I"        | 以补零后的十进制数表示的小时（12 | 01, 02, ..., 12          | (9)     |
|             | 小时制）。                       |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%p"        | 本地化的 AM 或 PM 。             | AM, PM (en_US); am, pm   | (1),    |
|             |                                  | (de_DE)                  | (3)     |
+-------------+----------------------------------+--------------------------+---------+
| "%M"        | 补零后，以十进制数显示的分钟。   | 00, 01, ..., 59          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%S"        | 补零后，以十进制数显示的秒。     | 00, 01, ..., 59          | (4),    |
|             |                                  |                          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%f"        | 以十进制数表示的毫秒，在左侧补零 | 000000, 000001, ...,     | (5)     |
|             | 。                               | 999999                   |         |
+-------------+----------------------------------+--------------------------+---------+
| "%z"        | UTC 偏移量，格式为               | (空), +0000, -0400,      | (6)     |
|             | "±HHMM[SS[.ffffff]]" （如果对象  | +1030, +063415,          |         |
|             | 是朴素的，则为空字符 串）。      | -030712.345216           |         |
+-------------+----------------------------------+--------------------------+---------+
| "%Z"        | 时区名称（如果对象为无知型则为空 | (空), UTC, EST, CST      |         |
|             | 字符串）。                       |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%j"        | 以补零后的十进制数表示的一年中的 | 001, 002, ..., 366       | (9)     |
|             | 日序号。                         |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%U"        | 以补零后的十进制数表示的一年中的 | 00, 01, ..., 53          | (7),    |
|             | 周序号（星期日作为每周的第一天） |                          | (9)     |
|             | 。 在 新的一年中第一个星期日之前 |                          |         |
|             | 的所有日子都被视为是在第 0 周。  |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%W"        | 以十进制数表示的一年中的周序号（ | 00, 01, ..., 53          | (7),    |
|             | 星期一作为每周的第一天）。 在新  |                          | (9)     |
|             | 的一年 中第一个第期一之前的所有  |                          |         |
|             | 日子都被视为是在第 0 周。        |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%c"        | 本地化的适当日期和时间表示。     | Tue Aug 16 21:30:00 1988 | (1)     |
|             |                                  | (en_US); Di 16 Aug       |         |
|             |                                  | 21:30:00 1988 (de_DE)    |         |
+-------------+----------------------------------+--------------------------+---------+
| "%x"        | 本地化的适当日期表示。           | 08/16/88 (None);         | (1)     |
|             |                                  | 08/16/1988 (en_US);      |         |
|             |                                  | 16.08.1988 (de_DE)       |         |
+-------------+----------------------------------+--------------------------+---------+
| "%X"        | 本地化的适当时间表示。           | 21:30:00 (en_US);        | (1)     |
|             |                                  | 21:30:00 (de_DE)         |         |
+-------------+----------------------------------+--------------------------+---------+
| "%%"        | 字面的 "'%'" 字符。              | %                        |         |
+-------------+----------------------------------+--------------------------+---------+

为了方便起见，还包括了C89标准不需要的其他一些指令。这些参数都对应于ISO
8601日期值。

+-------------+----------------------------------+--------------------------+---------+
| 指令        | 意义                             | 示例                     | 注释    |
|=============|==================================|==========================|=========|
| "%G"        | 带有世纪的 ISO 8601 年份，表示包 | 0001, 0002, ..., 2013,   | (8)     |
|             | 含大部分 ISO 星期 ("%V") 的年份  | 2014, ..., 9998, 9999    |         |
|             | 。                               |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%u"        | 以十进制数显示的 ISO 8601 星期中 | 1, 2, ..., 7             |         |
|             | 的日序号，其中 1 表示星期一。    |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%V"        | 以十进制数显示的 ISO 8601 星期， | 01, 02, ..., 53          | (8),    |
|             | 以星期一作为每周的第一天。 第 01 |                          | (9)     |
|             | 周为 包含 1 月 4 日的星期。      |                          |         |
+-------------+----------------------------------+--------------------------+---------+

These may not be available on all platforms when used with the
"strftime()" method. The ISO 8601 year and ISO 8601 week directives
are not interchangeable with the year and week number directives
above. Calling "strptime()" with incomplete or ambiguous ISO 8601
directives will raise a "ValueError".

The full set of format codes supported varies across platforms,
because Python calls the platform C library's "strftime()" function,
and platform variations are common. To see the full set of format
codes supported on your platform, consult the *strftime(3)*
documentation.

3.6 新版功能: 增加了 "%G",  "%u"  和 "%V"。


技术细节
--------

Broadly speaking, "d.strftime(fmt)" acts like the "time" module's
"time.strftime(fmt, d.timetuple())" although not all objects support a
"timetuple()" method.

对于 "datetime.strptime()" 类方法，默认值为 "1900-01-01T00:00:00.000":
任何未在格式字符串中指定的部分都将从默认值中提取。 [4]

Using "datetime.strptime(date_string, format)" is equivalent to:

   datetime(*(time.strptime(date_string, format)[0:6]))

except when the format includes sub-second components or timezone
offset information, which are supported in "datetime.strptime" but are
discarded by "time.strptime".

For "time" objects, the format codes for year, month, and day should
not be used, as "time" objects have no such values. If they're used
anyway, "1900" is substituted for the year, and "1" for the month and
day.

For "date" objects, the format codes for hours, minutes, seconds, and
microseconds should not be used, as "date" objects have no such
values. If they're used anyway, "0" is substituted for them.

出于相同的原因，对于包含当前区域设置字符集所无法表示的 Unicode 码位的
格式字符串的处理方式也取决于具体平台。 在某些平台上这样的码位会不加修
改地原样输出，而在其他平台上 "strftime" 则可能引发 "UnicodeError" 或只
返回一个空字符串。

注释:

1. 由于此格式依赖于当前区域设置，因此对具体输出值应当保持谨慎预期。
   字 段顺序会发生改变（例如 "month/day/year" 与 "day/month/year"），
   并且 输出可能包含使用区域设置所指定的默认编码格式的 Unicode 字符（
   例如如 果当前区域为 "ja_JP"，则默认编码格式可能为 "eucJP", "SJIS"
   或 "utf-8" 中的一个；使用 "locale.getlocale()" 可确定当前区域设置的
   编 码格式）。

2. "strptime()" 方法能够解析整个 [1, 9999] 范围内的年份，但 < 1000
   的 年份必须加零填充为 4 位数字宽度。

   在 3.2 版更改: 在之前的版本中，"strftime()" 方法只限于 >= 1900 的年
   份。

   在 3.3 版更改: 在版本3.2中，"strftime()" 方法只限于 years >= 1000。

3. 当与 "strptime()" 方法一起使用时，如果使用 "%I" 指令来解析小时，
   "%p" 指令只影响输出小时字段。

4. 与 "time" 模块不同的是， "datetime" 模块不支持闰秒。

5. When used with the "strptime()" method, the "%f" directive
   accepts from one to six digits and zero pads on the right. "%f" is
   an extension to the set of format characters in the C standard (but
   implemented separately in datetime objects, and therefore always
   available).

6. 对于无知型对象，"%z" and "%Z" 格式代码会被替换为空字符串。

   对于一个感知型对象而言：

   "%z"
      "utcoffset()" is transformed into a string of the form
      "±HHMM[SS[.ffffff]]", where "HH" is a 2-digit string giving the
      number of UTC offset hours, "MM" is a 2-digit string giving the
      number of UTC offset minutes, SS is a 2-digit string giving the
      number of UTC offset seconds and "ffffff" is a 6-digit string
      giving the number of UTC offset microseconds. The "ffffff" part
      is omitted when the offset is a whole number of seconds and both
      the "ffffff" and the "SS" part is omitted when the offset is a
      whole number of minutes. For example, if "utcoffset()" returns
      "timedelta(hours=-3, minutes=-30)", "%z" is replaced with the
      string "'-0330'".

   在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。

   在 3.7 版更改: 当提供 "%z" 指令给 "strptime()" 方法时，UTC 差值可以
   在时、分和秒之间使用冒号分隔符。 例如，"'+01:00:00'" 将被解读为一小
   时的差值。 此外，提供 "'Z'" 就相当于 "'+00:00'"。

   "%Z"
      If "tzname()" returns "None", "%Z" is replaced by an empty
      string. Otherwise "%Z" is replaced by the returned value, which
      must be a string.

   在 3.2 版更改: When the "%z" directive is provided to the
   "strptime()" method, an aware "datetime" object will be produced.
   The "tzinfo" of the result will be set to a "timezone" instance.

7. 当与 "strptime()" 方法一起使用时，"%U" 和 "%W" 仅用于指定星期几
   和日 历年份 ("%Y") 的计算。

8. 类似于 "%U" 和 "%W"，"%V" 仅用于在 "strptime()" 格式字符串中指定
   星 期几和 ISO 年份 ("%G") 的计算。 还要注意 "%G" 和 "%Y" 是不可交换
   的 。

9. 当于 "strptime()" 方法一起使用时，前导的零在格式 "%d", "%m",
   "%H", "%I", "%M", "%S", "%J", "%U", "%W" 和 "%V" 中是可选的。 格式
   "%y" 不要求有前导的零。

-[ 脚注 ]-

[1] 就是说如果我们忽略相对论效应的话。

[2] This matches the definition of the "proleptic Gregorian"
    calendar in Dershowitz and Reingold's book *Calendrical
    Calculations*, where it's the base calendar for all computations.
    See the book for algorithms for converting between proleptic
    Gregorian ordinals and many other calendar systems.

[3] See R. H. van Gent's guide to the mathematics of the ISO 8601
    calendar for a good explanation.

[4] 传入 "datetime.strptime('Feb 29', '%b %d')" 将导致错误，因为
    "1900" 不是闰年。
