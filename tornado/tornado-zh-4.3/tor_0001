    multiple IP addresses, which is most common for mixed IPv4 and IPv6 use).

    Address may be either an IP address or hostname. If it’s a hostname, the server will listen
    on all IP addresses associated with the name. Address may be an empty string or None to
    listen on all available interfaces. Family may be set to either socket.AF_INET or
    socket.AF_INET6 to restrict to IPv4 or IPv6 addresses, otherwise both will be used if
    available.

    The backlog argument has the same meaning as for socket.listen().

    flags is a bitmask of AI_* flags to getaddrinfo, like socket.AI_PASSIVE | 
    socket.AI_NUMERICHOST.

    resuse_port option sets SO_REUSEPORT option for every socket in the list. If your platform
    doesn’t support this option ValueError will be raised.

tornado.netutil.bind_unix_socket(file, mode=384, backlog=128)[源代码]¶

    Creates a listening unix socket.

    If a socket with the given name already exists, it will be deleted. If any other file with
    that name exists, an exception will be raised.

    Returns a socket object (not a list of socket objects like bind_sockets)

tornado.netutil.add_accept_handler(sock, callback, io_loop=None)[源代码]¶

    Adds an IOLoop event handler to accept new connections on sock.

    When a connection is accepted, callback(connection, address) will be run (connection is a
    socket object, and address is the address of the other end of the connection). Note that
    this signature is different from the callback(fd, events) signature used for IOLoop
    handlers.

    在 4.1 版更改: The io_loop argument is deprecated.

tornado.netutil.is_valid_ip(ip)[源代码]¶

    Returns true if the given string is a well-formed IP address.

    Supports IPv4 and IPv6.

class tornado.netutil.Resolver[源代码]¶

    Configurable asynchronous DNS resolver interface.

    By default, a blocking implementation is used (which simply calls socket.getaddrinfo). An
    alternative implementation can be chosen with the Resolver.configure class method:

    Resolver.configure('tornado.netutil.ThreadedResolver')

    The implementations of this interface included with Tornado are

      □ tornado.netutil.BlockingResolver
      □ tornado.netutil.ThreadedResolver
      □ tornado.netutil.OverrideResolver
      □ tornado.platform.twisted.TwistedResolver
      □ tornado.platform.caresresolver.CaresResolver

    resolve(host, port, family=<AddressFamily.AF_UNSPEC: 0>, callback=None)[源代码]¶

        Resolves an address.

        The host argument is a string which may be a hostname or a literal IP address.

        Returns a Future whose result is a list of (family, address) pairs, where address is a
        tuple suitable to pass to socket.connect (i.e. a (host, port) pair for IPv4; additional
        fields may be present for IPv6). If a callback is passed, it will be run with the result
        as an argument when it is complete.

    close()[源代码]¶

        Closes the Resolver, freeing any resources used.

        3.1 新版功能.

class tornado.netutil.ExecutorResolver[源代码]¶

    Resolver implementation using a concurrent.futures.Executor.

    Use this instead of ThreadedResolver when you require additional control over the executor
    being used.

    The executor will be shut down when the resolver is closed unless close_resolver=False; use
    this if you want to reuse the same executor elsewhere.

    在 4.1 版更改: The io_loop argument is deprecated.

class tornado.netutil.BlockingResolver[源代码]¶

    Default Resolver implementation, using socket.getaddrinfo.

    The IOLoop will be blocked during the resolution, although the callback will not be run
    until the next IOLoop iteration.

class tornado.netutil.ThreadedResolver[源代码]¶

    Multithreaded non-blocking Resolver implementation.

    Requires the concurrent.futures package to be installed (available in the standard library
    since Python 3.2, installable with pip install futures in older versions).

    The thread pool size can be configured with:

    Resolver.configure('tornado.netutil.ThreadedResolver',
                       num_threads=10)

    在 3.1 版更改: All ThreadedResolvers share a single thread pool, whose size is set by the
    first one to be created.

class tornado.netutil.OverrideResolver[源代码]¶

    Wraps a resolver with a mapping of overrides.

    This can be used to make local DNS changes (e.g. for testing) without modifying system-wide
    settings.

    The mapping can contain either host strings or host-port pairs.

tornado.netutil.ssl_options_to_context(ssl_options)[源代码]¶

    Try to convert an ssl_options dictionary to an SSLContext object.

    The ssl_options dictionary contains keywords to be passed to ssl.wrap_socket. In Python
    2.7.9+, ssl.SSLContext objects can be used instead. This function converts the dict form to
    its SSLContext equivalent, and may be used when a component which accepts both forms needs
    to upgrade to the SSLContext version to use features like SNI or NPN.

tornado.netutil.ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs)[源代码]¶

    Returns an ssl.SSLSocket wrapping the given socket.

    ssl_options may be either an ssl.SSLContext object or a dictionary (as accepted by
    ssl_options_to_context). Additional keyword arguments are passed to wrap_socket (either the
    SSLContext method or the ssl module function as appropriate).

tornado.tcpclient — IOStream connection factory¶

A non-blocking TCP connection factory.

class tornado.tcpclient.TCPClient(resolver=None, io_loop=None)[源代码]¶

    A non-blocking TCP connection factory.

    在 4.1 版更改: The io_loop argument is deprecated.

    connect(host, port, af=<AddressFamily.AF_UNSPEC: 0>, ssl_options=None, max_buffer_size=None)
        [源代码]¶

        Connect to the given host and port.

        Asynchronously returns an IOStream (or SSLIOStream if ssl_options is not None).

tornado.tcpserver — 基于 IOStream 的基础 TCP 服务¶

一个非阻塞, 单线程 TCP 服务.

class tornado.tcpserver.TCPServer(io_loop=None, ssl_options=None, max_buffer_size=None, 
    read_chunk_size=None)[源代码]¶

    一个非阻塞, 单线程的 TCP 服务.

    想要使用 TCPServer, 只需要定义一个子类, 复写 handle_stream 方法即可. 例如, 一个简单的 echo
    server 可以做如下定义:

    from tornado.tcpserver import TCPServer
    from tornado.iostream import StreamClosedError
    from tornado import gen

    class EchoServer(TCPServer):
        @gen.coroutine
        def handle_stream(self, stream, address):
            while True:
                try:
                    data = yield stream.read_until(b"\n")
                    yield stream.write(data)
                except StreamClosedError:
                    break

    为了使该服务提供 SSL 传输, 通过一个名为``ssl_options`` 的关键字参数传递进去 ssl.SSLContext
    对象即可. 为了兼容旧版本的 Python, ssl_options 也可以是一个字典, 作为`ssl.wrap_socket` 方法
    的关键字参数.:

    ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    ssl_ctx.load_cert_chain(os.path.join(data_dir, "mydomain.crt"),
                            os.path.join(data_dir, "mydomain.key"))
    TCPServer(ssl_options=ssl_ctx)

    TCPServer 初始化可以是以下三种模式之一:

     1. listen: 简单的单进程模式:

        server = TCPServer()
        server.listen(8888)
        IOLoop.current().start()

     2. bind/start: 简单的多进程模式:

        server = TCPServer()
        server.bind(8888)
        server.start(0)  # Forks multiple sub-processes
        IOLoop.current().start()

        当使用这个接口, IOLoop 一定不能被传递给 TCPServer 构造器. start 总是会在默认单一的
        IOLoop 上启动服务.

     3. add_sockets: 高级多进程模式:

        sockets = bind_sockets(8888)
        tornado.process.fork_processes(0)
        server = TCPServer()
        server.add_sockets(sockets)
        IOLoop.current().start()

        add_sockets 接口更加复杂, 但是它可以和 tornado.process.fork_processes 一起被使用, 当
        fork 发生的时候给你更多灵活性. add_sockets 也可以被用于单进程服务中, 如果你想要使用
        bind_sockets 以外的方式创建你监听的 socket.

    3.1 新版功能: max_buffer_size 参数.

    listen(port, address='')[源代码]¶

        开始在给定的端口接收连接.

        这个方法可能不只被调用一次, 可能会在多个端口上被调用多次. listen 方法将立即生效, 所以它
        没必要在 TCPServer.start 之后调用. 然而, 必须要启动 IOLoop 才可以.

    add_sockets(sockets)[源代码]¶

        使服务开始接收给定端口的连接.

        sockets 参数是一个 socket 对象的列表, 例如那些被 bind_sockets 所返回的对象. add_sockets
        通常和 tornado.process.fork_processes 相结合使用, 以便于在一个多进程服务初始化时提供更多
        控制.

    add_socket(socket)[源代码]¶

        单数版本的 add_sockets. 接受一个单一的 socket 对象.

    bind(port, address=None, family=<AddressFamily.AF_UNSPEC: 0>, backlog=128)[源代码]¶

        绑定该服务到指定的地址的指定端口上.

        要启动该服务, 调用 start. 如果你想要在一个单进程上运行该服务, 你可以调用 listen 作为顺序
        调用 bind 和 start 的一个快捷方式.

        address 参数可以是 IP 地址或者主机名. 如果它是主机名, 该服务将监听在和该名称有关的所有
        IP 地址上. 地址也可以是空字符串或者 None, 服务将监听所有可用的接口. family 可以被设置为
        socket.AF_INET 或 socket.AF_INET6 用来限定是 IPv4 或 IPv6 地址, 否则如果可用的话, 两者都
        将被使用.

        backlog 参数和 socket.listen 是相同含义.

        这个方法可能在 start 之前被调用多次来监听在多个端口或接口上.

    start(num_processes=1)[源代码]¶

        在 IOLoop 中启动该服务.

        默认情况下, 我们在该进程中运行服务, 并且不会 fork 出任何额外的子进程.

        如果 num_processes 为 None 或 <= 0, 我们检测这台机器上可用的核心数并 fork 相同数量的子进
        程. 如果给定了 num_processes 并且 > 1, 我们 fork 指定数量的子进程.

        因为我们使用进程而不是线程, 在任何服务代码之间没有共享内存.

        注意多进程模式和 autoreload 模块不兼容(或者是当 debug=True 时 tornado.web.Application 的
        autoreload=True 选项默认为 True). 当使用多进程模式时, 直到 TCPServer.start(n) 调用后, 才
        能创建或者引用 IOLoops .

    stop()[源代码]¶

        停止对新连接的监听.

        正在进行的请求可能仍然会继续在服务停止之后.

    handle_stream(stream, address)[源代码]¶

        通过复写这个方法以处理一个来自传入连接的新 IOStream .

        这个方法可能是一个协程; 如果是这样, 异步引发的任何异常都将被记录. 接受传入连接不会被该协
        程阻塞.

        如果这个 TCPServer 被配置为 SSL, handle_stream 将在 SSL 握手完成前被调用. 如果你需要验证
        客户端的证书或使用 NPN/ALPN 请使用 SSLIOStream.wait_for_handshake .

        在 4.2 版更改: 给这个方法添加了选项, 可以为协程.

协程和并发¶

tornado.gen — Simplify asynchronous code¶

tornado.gen is a generator-based interface to make it easier to work in an asynchronous
environment. Code using the gen module is technically asynchronous, but it is written as a
single generator instead of a collection of separate functions.

For example, the following asynchronous handler:

class AsyncHandler(RequestHandler):
    @asynchronous
    def get(self):
        http_client = AsyncHTTPClient()
        http_client.fetch("http://example.com",
                          callback=self.on_fetch)

    def on_fetch(self, response):
        do_something_with_response(response)
        self.render("template.html")

could be written with gen as:

class GenAsyncHandler(RequestHandler):
    @gen.coroutine
    def get(self):
        http_client = AsyncHTTPClient()
        response = yield http_client.fetch("http://example.com")
        do_something_with_response(response)
        self.render("template.html")

Most asynchronous functions in Tornado return a Future; yielding this object returns its result.

You can also yield a list or dict of Futures, which will be started at the same time and run in
parallel; a list or dict of results will be returned when they are all finished:

@gen.coroutine
def get(self):
    http_client = AsyncHTTPClient()
    response1, response2 = yield [http_client.fetch(url1),
                                  http_client.fetch(url2)]
    response_dict = yield dict(response3=http_client.fetch(url3),
                               response4=http_client.fetch(url4))
    response3 = response_dict['response3']
    response4 = response_dict['response4']

If the singledispatch library is available (standard in Python 3.4, available via the
singledispatch package on older versions), additional types of objects may be yielded. Tornado
includes support for asyncio.Future and Twisted’s Deferred class when tornado.platform.asyncio
and tornado.platform.twisted are imported. See the convert_yielded function to extend this
mechanism.

在 3.2 版更改: Dict support added.

在 4.1 版更改: Support added for yielding asyncio Futures and Twisted Deferreds via 
singledispatch.

Decorators¶

tornado.gen.coroutine(func, replace_callback=True)[源代码]¶

    Decorator for asynchronous generators.

    Any generator that yields objects from this module must be wrapped in either this decorator
    or engine.

    Coroutines may “return” by raising the special exception Return(value). In Python 3.3+, it
    is also possible for the function to simply use the return value statement (prior to Python
    3.3 generators were not allowed to also return values). In all versions of Python a
    coroutine that simply wishes to exit early may use the return statement without a value.

    Functions with this decorator return a Future. Additionally, they may be called with a 
    callback keyword argument, which will be invoked with the future’s result when it resolves.
    If the coroutine fails, the callback will not be run and an exception will be raised into
    the surrounding StackContext. The callback argument is not visible inside the decorated
    function; it is handled by the decorator itself.

    From the caller’s perspective, @gen.coroutine is similar to the combination of 
    @return_future and @gen.engine.

    警告

    When exceptions occur inside a coroutine, the exception information will be stored in the
    Future object. You must examine the result of the Future object, or the exception may go
    unnoticed by your code. This means yielding the function if called from another coroutine,
    using something like IOLoop.run_sync for top-level calls, or passing the Future to
    IOLoop.add_future.

tornado.gen.engine(func)[源代码]¶

    Callback-oriented decorator for asynchronous generators.

    This is an older interface; for new code that does not need to be compatible with versions
    of Tornado older than 3.0 the coroutine decorator is recommended instead.

    This decorator is similar to coroutine, except it does not return a Future and the callback
    argument is not treated specially.

    In most cases, functions decorated with engine should take a callback argument and invoke it
    with their result when they are finished. One notable exception is the RequestHandler HTTP
    verb methods, which use self.finish() in place of a callback argument.

Utility functions¶

exception tornado.gen.Return(value=None)[源代码]¶

    Special exception to return a value from a coroutine.

    If this exception is raised, its value argument is used as the result of the coroutine:

    @gen.coroutine
    def fetch_json(url):
        response = yield AsyncHTTPClient().fetch(url)
        raise gen.Return(json_decode(response.body))

    In Python 3.3, this exception is no longer necessary: the return statement can be used
    directly to return a value (previously yield and return with a value could not be combined
    in the same function).

    By analogy with the return statement, the value argument is optional, but it is never
    necessary to raise gen.Return(). The return statement can be used with no arguments instead.

tornado.gen.with_timeout(timeout, future, io_loop=None, quiet_exceptions=())[源代码]¶

    Wraps a Future in a timeout.

    Raises TimeoutError if the input future does not complete before timeout, which may be
    specified in any form allowed by IOLoop.add_timeout (i.e. a datetime.timedelta or an
    absolute time relative to IOLoop.time)

    If the wrapped Future fails after it has timed out, the exception will be logged unless it
    is of a type contained in quiet_exceptions (which may be an exception type or a sequence of
    types).

    Currently only supports Futures, not other YieldPoint classes.

    4.0 新版功能.

    在 4.1 版更改: Added the quiet_exceptions argument and the logging of unhandled exceptions.

exception tornado.gen.TimeoutError[源代码]¶

    Exception raised by with_timeout.

tornado.gen.sleep(duration)[源代码]¶

    Return a Future that resolves after the given number of seconds.

    When used with yield in a coroutine, this is a non-blocking analogue to time.sleep (which
    should not be used in coroutines because it is blocking):

    yield gen.sleep(0.5)

    Note that calling this function on its own does nothing; you must wait on the Future it
    returns (usually by yielding it).

    4.1 新版功能.

tornado.gen.moment¶

    A special object which may be yielded to allow the IOLoop to run for one iteration.

    This is not needed in normal use but it can be helpful in long-running coroutines that are
    likely to yield Futures that are ready instantly.

    Usage: yield gen.moment

    4.0 新版功能.

class tornado.gen.WaitIterator(*args, **kwargs)[源代码]¶

    Provides an iterator to yield the results of futures as they finish.

    Yielding a set of futures like this:

    results = yield [future1, future2]

    pauses the coroutine until both future1 and future2 return, and then restarts the coroutine
    with the results of both futures. If either future is an exception, the expression will
    raise that exception and all the results will be lost.

    If you need to get the result of each future as soon as possible, or if you need the result
    of some futures even if others produce errors, you can use WaitIterator:

    wait_iterator = gen.WaitIterator(future1, future2)
    while not wait_iterator.done():
        try:
            result = yield wait_iterator.next()
        except Exception as e:
            print("Error {} from {}".format(e, wait_iterator.current_future))
        else:
            print("Result {} received from {} at {}".format(
                result, wait_iterator.current_future,
                wait_iterator.current_index))

    Because results are returned as soon as they are available the output from the iterator will
    not be in the same order as the input arguments. If you need to know which future produced
    the current result, you can use the attributes WaitIterator.current_future, or 
    WaitIterator.current_index to get the index of the future from the input list. (if keyword
    arguments were used in the construction of the WaitIterator, current_index will use the
    corresponding keyword).

    On Python 3.5, WaitIterator implements the async iterator protocol, so it can be used with
    the async for statement (note that in this version the entire iteration is aborted if any
    value raises an exception, while the previous example can continue past individual errors):

    async for result in gen.WaitIterator(future1, future2):
        print("Result {} received from {} at {}".format(
            result, wait_iterator.current_future,
            wait_iterator.current_index))

    4.1 新版功能.

    在 4.3 版更改: Added async for support in Python 3.5.

    done()[源代码]¶

        Returns True if this iterator has no more results.

    next()[源代码]¶

        Returns a Future that will yield the next available result.

        Note that this Future will not be the same object as any of the inputs.

tornado.gen.multi(children, quiet_exceptions=())[源代码]¶

    Runs multiple asynchronous operations in parallel.

    children may either be a list or a dict whose values are yieldable objects. multi() returns
    a new yieldable object that resolves to a parallel structure containing their results. If 
    children is a list, the result is a list of results in the same order; if it is a dict, the
    result is a dict with the same keys.

    That is, results = yield multi(list_of_futures) is equivalent to:

    results = []
    for future in list_of_futures:
        results.append(yield future)

    If any children raise exceptions, multi() will raise the first one. All others will be
    logged, unless they are of types contained in the quiet_exceptions argument.

    If any of the inputs are YieldPoints, the returned yieldable object is a YieldPoint.
    Otherwise, returns a Future. This means that the result of multi can be used in a native
    coroutine if and only if all of its children can be.

    In a yield-based coroutine, it is not normally necessary to call this function directly,
    since the coroutine runner will do it automatically when a list or dict is yielded. However,
    it is necessary in await-based coroutines, or to pass the quiet_exceptions argument.

    This function is available under the names multi() and Multi() for historical reasons.

    在 4.2 版更改: If multiple yieldables fail, any exceptions after the first (which is raised)
    will be logged. Added the quiet_exceptions argument to suppress this logging for selected
    exception types.

    在 4.3 版更改: Replaced the class Multi and the function multi_future with a unified
    function multi. Added support for yieldables other than YieldPoint and Future.

tornado.gen.multi_future(children, quiet_exceptions=())[源代码]¶

    Wait for multiple asynchronous futures in parallel.

    This function is similar to multi, but does not support YieldPoints.

    4.0 新版功能.

    在 4.2 版更改: If multiple Futures fail, any exceptions after the first (which is raised)
    will be logged. Added the quiet_exceptions argument to suppress this logging for selected
    exception types.

    4.3 版后已移除: Use multi instead.

tornado.gen.Task(func, *args, **kwargs)[源代码]¶

    Adapts a callback-based asynchronous function for use in coroutines.

    Takes a function (and optional additional arguments) and runs it with those arguments plus a
    callback keyword argument. The argument passed to the callback is returned as the result of
    the yield expression.

    在 4.0 版更改: gen.Task is now a function that returns a Future, instead of a subclass of
    YieldPoint. It still behaves the same way when yielded.

class tornado.gen.Arguments¶

    The result of a Task or Wait whose callback had more than one argument (or keyword
    arguments).

    The Arguments object is a collections.namedtuple and can be used either as a tuple (args, 
    kwargs) or an object with attributes args and kwargs.

tornado.gen.convert_yielded(yielded)[源代码]¶

    Convert a yielded object into a Future.

    The default implementation accepts lists, dictionaries, and Futures.

    If the singledispatch library is available, this function may be extended to support
    additional types. For example:

    @convert_yielded.register(asyncio.Future)
    def _(asyncio_future):
        return tornado.platform.asyncio.to_tornado_future(asyncio_future)

    4.1 新版功能.

tornado.gen.maybe_future(x)[源代码]¶

    Converts x into a Future.

    If x is already a Future, it is simply returned; otherwise it is wrapped in a new Future.
    This is suitable for use as result = yield gen.maybe_future(f()) when you don’t know whether
    f() returns a Future or not.

    4.3 版后已移除: This function only handles Futures, not other yieldable objects. Instead of
    maybe_future, check for the non-future result types you expect (often just None), and yield
    anything unknown.

Legacy interface¶

Before support for Futures was introduced in Tornado 3.0, coroutines used subclasses of
YieldPoint in their yield expressions. These classes are still supported but should generally
not be used except for compatibility with older interfaces. None of these classes are compatible
with native (await-based) coroutines.

class tornado.gen.YieldPoint[源代码]¶

    Base class for objects that may be yielded from the generator.

    4.0 版后已移除: Use Futures instead.

    start(runner)[源代码]¶

        Called by the runner after the generator has yielded.

        No other methods will be called on this object before start.

    is_ready()[源代码]¶

        Called by the runner to determine whether to resume the generator.

        Returns a boolean; may be called more than once.

    get_result()[源代码]¶

        Returns the value to use as the result of the yield expression.

        This method will only be called once, and only after is_ready has returned true.

class tornado.gen.Callback(key)[源代码]¶

    Returns a callable object that will allow a matching Wait to proceed.

    The key may be any value suitable for use as a dictionary key, and is used to match 
    Callbacks to their corresponding Waits. The key must be unique among outstanding callbacks
    within a single run of the generator function, but may be reused across different runs of
    the same function (so constants generally work fine).

    The callback may be called with zero or one arguments; if an argument is given it will be
    returned by Wait.

    4.0 版后已移除: Use Futures instead.

class tornado.gen.Wait(key)[源代码]¶

    Returns the argument passed to the result of a previous Callback.

    4.0 版后已移除: Use Futures instead.

class tornado.gen.WaitAll(keys)[源代码]¶

    Returns the results of multiple previous Callbacks.

    The argument is a sequence of Callback keys, and the result is a list of results in the same
    order.

    WaitAll is equivalent to yielding a list of Wait objects.

    4.0 版后已移除: Use Futures instead.

class tornado.gen.MultiYieldPoint(children, quiet_exceptions=())[源代码]¶

    Runs multiple asynchronous operations in parallel.

    This class is similar to multi, but it always creates a stack context even when no children
    require it. It is not compatible with native coroutines.

    在 4.2 版更改: If multiple YieldPoints fail, any exceptions after the first (which is
    raised) will be logged. Added the quiet_exceptions argument to suppress this logging for
    selected exception types.

    在 4.3 版更改: Renamed from Multi to MultiYieldPoint. The name Multi remains as an alias for
    the equivalent multi function.

    4.3 版后已移除: Use multi instead.

tornado.concurrent — Work with threads and futures¶

Utilities for working with threads and Futures.

Futures are a pattern for concurrent programming introduced in Python 3.2 in the
concurrent.futures package. This package defines a mostly-compatible Future class designed for
use from coroutines, as well as some utility functions for interacting with the
concurrent.futures package.

class tornado.concurrent.Future[源代码]¶

    Placeholder for an asynchronous result.

    A Future encapsulates the result of an asynchronous operation. In synchronous applications 
    Futures are used to wait for the result from a thread or process pool; in Tornado they are
    normally used with IOLoop.add_future or by yielding them in a gen.coroutine.

    tornado.concurrent.Future is similar to concurrent.futures.Future, but not thread-safe (and
    therefore faster for use with single-threaded event loops).

    In addition to exception and set_exception, methods exc_info and set_exc_info are supported
    to capture tracebacks in Python 2. The traceback is automatically available in Python 3, but
    in the Python 2 futures backport this information is discarded. This functionality was
    previously available in a separate class TracebackFuture, which is now a deprecated alias
    for this class.

    在 4.0 版更改: tornado.concurrent.Future is always a thread-unsafe Future with support for
    the exc_info methods. Previously it would be an alias for the thread-safe
    concurrent.futures.Future if that package was available and fall back to the thread-unsafe
    implementation if it was not.

    在 4.1 版更改: If a Future contains an error but that error is never observed (by calling 
    result(), exception(), or exc_info()), a stack trace will be logged when the Future is
    garbage collected. This normally indicates an error in the application, but in cases where
    it results in undesired logging it may be necessary to suppress the logging by ensuring that
    the exception is observed: f.add_done_callback(lambda f: f.exception()).

Consumer methods¶

Future.result(timeout=None)[源代码]¶

    If the operation succeeded, return its result. If it failed, re-raise its exception.

    This method takes a timeout argument for compatibility with concurrent.futures.Future but it
    is an error to call it before the Future is done, so the timeout is never used.

Future.exception(timeout=None)[源代码]¶

    If the operation raised an exception, return the Exception object. Otherwise returns None.

    This method takes a timeout argument for compatibility with concurrent.futures.Future but it
    is an error to call it before the Future is done, so the timeout is never used.

Future.exc_info()[源代码]¶

    Returns a tuple in the same format as sys.exc_info or None.

    4.0 新版功能.

Future.add_done_callback(fn)[源代码]¶

    Attaches the given callback to the Future.

    It will be invoked with the Future as its argument when the Future has finished running and
    its result is available. In Tornado consider using IOLoop.add_future instead of calling
    add_done_callback directly.

Future.done()[源代码]¶

    Returns True if the future has finished running.

Future.running()[源代码]¶

    Returns True if this operation is currently running.

Future.cancel()[源代码]¶

    Cancel the operation, if possible.

    Tornado Futures do not support cancellation, so this method always returns False.

Future.cancelled()[源代码]¶

    Returns True if the operation has been cancelled.

    Tornado Futures do not support cancellation, so this method always returns False.

Producer methods¶

Future.set_result(result)[源代码]¶

    Sets the result of a Future.

    It is undefined to call any of the set methods more than once on the same object.

Future.set_exception(exception)[源代码]¶

    Sets the exception of a Future.

Future.set_exc_info(exc_info)[源代码]¶

    Sets the exception information of a Future.

    Preserves tracebacks on Python 2.

    4.0 新版功能.

tornado.concurrent.run_on_executor(*args, **kwargs)[源代码]¶

    Decorator to run a synchronous method asynchronously on an executor.

    The decorated method may be called with a callback keyword argument and returns a future.

    The IOLoop and executor to be used are determined by the io_loop and executor attributes of 
    self. To use different attributes, pass keyword arguments to the decorator:

    @run_on_executor(executor='_thread_pool')
    def foo(self):
        pass

    在 4.2 版更改: Added keyword arguments to use alternative attributes.

tornado.concurrent.return_future(f)[源代码]¶

    Decorator to make a function that returns via callback return a Future.

    The wrapped function should take a callback keyword argument and invoke it with one argument
    when it has finished. To signal failure, the function can simply raise an exception (which
    will be captured by the StackContext and passed along to the Future).

    From the caller’s perspective, the callback argument is optional. If one is given, it will
    be invoked when the function is complete with Future.result() as an argument. If the
    function fails, the callback will not be run and an exception will be raised into the
    surrounding StackContext.

    If no callback is given, the caller should use the Future to wait for the function to
    complete (perhaps by yielding it in a gen.engine function, or passing it to
    IOLoop.add_future).

    Usage:

    @return_future
    def future_func(arg1, arg2, callback):
        # Do stuff (possibly asynchronous)
        callback(result)

    @gen.engine
    def caller(callback):
        yield future_func(arg1, arg2)
        callback()

    Note that @return_future and @gen.engine can be applied to the same function, provided 
    @return_future appears first. However, consider using @gen.coroutine instead of this
    combination.

tornado.concurrent.chain_future(a, b)[源代码]¶

    Chain two futures together so that when one completes, so does the other.

    The result (success or failure) of a will be copied to b, unless b has already been
    completed or cancelled by the time a finishes.

tornado.locks – 同步原语¶

4.2 新版功能.

使用和标准库提供给线程相似的同步原语协调协程.

(请注意, 这些原语不是线程安全的, 不能被用来代替标准库中的–它们是为了协调在单线程app中的Tornado协
程, 而不是为了在一个多线程 app中保护共享对象.)

Condition¶

class tornado.locks.Condition[源代码]¶

    允许一个或多个协程等待直到被通知的条件.

    就像标准的 threading.Condition, 但是不需要一个被获取和释放的底层锁.

    通过 Condition, 协程可以等待着被其他协程通知:

    from tornado import gen
    from tornado.ioloop import IOLoop
    from tornado.locks import Condition

    condition = Condition()

    @gen.coroutine
    def waiter():
        print("I'll wait right here")
        yield condition.wait()  # Yield a Future.
        print("I'm done waiting")

    @gen.coroutine
    def notifier():
        print("About to notify")
        condition.notify()
        print("Done notifying")

    @gen.coroutine
    def runner():
        # Yield two Futures; wait for waiter() and notifier() to finish.
        yield [waiter(), notifier()]

    IOLoop.current().run_sync(runner)

    I'll wait right here
    About to notify
    Done notifying
    I'm done waiting

    wait 有一个可选参数 timeout , 要不然是一个绝对的时间戳:

    io_loop = IOLoop.current()

    # Wait up to 1 second for a notification.
    yield condition.wait(timeout=io_loop.time() + 1)

    ...或一个 datetime.timedelta 相对于当前时间的一个延时:

    # Wait up to 1 second.
    yield condition.wait(timeout=datetime.timedelta(seconds=1))

    这个方法将抛出一个 tornado.gen.TimeoutError 如果在最后时间之前都没有通知.

    wait(timeout=None)[源代码]¶

        等待 notify.

        返回一个 Future 对象, 如果条件被通知则为 True , 或者在超时之后为 False .

    notify(n=1)[源代码]¶

        唤醒 n 个等待者(waiters) .

    notify_all()[源代码]¶

        唤醒全部的等待者(waiters) .

Event¶

class tornado.locks.Event[源代码]¶

    一个阻塞协程的事件直到它的内部标识设置为True.

    类似于 threading.Event.

    协程可以等待一个事件被设置. 一旦它被设置, 调用 yield event.wait() 将不会被阻塞除非该事件已经
    被清除:

    from tornado import gen
    from tornado.ioloop import IOLoop
    from tornado.locks import Event

    event = Event()

    @gen.coroutine
    def waiter():
        print("Waiting for event")
        yield event.wait()
        print("Not waiting this time")
        yield event.wait()
        print("Done")

    @gen.coroutine
    def setter():
        print("About to set the event")
        event.set()

    @gen.coroutine
    def runner():
        yield [waiter(), setter()]

    IOLoop.current().run_sync(runner)

    Waiting for event
    About to set the event
    Not waiting this time
    Done

    is_set()[源代码]¶

        如果内部标识是true将返回 True .

    set()[源代码]¶

        设置内部标识为 True. 所有的等待者(waiters)都被唤醒.

        一旦该标识被设置调用 wait 将不会阻塞.

    clear()[源代码]¶

        重置内部标识为 False.

        调用 wait 将阻塞直到 set 被调用.

    wait(timeout=None)[源代码]¶

        阻塞直到内部标识为true.

        返回一个Future对象, 在超时之后会抛出一个 tornado.gen.TimeoutError 异常.

Semaphore¶

class tornado.locks.Semaphore(value=1)[源代码]¶

    可以在阻塞之前获得固定次数的锁.

    一个信号量管理着代表 release 调用次数减去 acquire 的调用次数的计数器, 加一个初始值. 如果必要
    的话,`.acquire` 方法将会阻塞, 直到它可以返回, 而不使该计数器成为负值.

    信号量限制访问共享资源. 为了允许两个worker同时获得权限:

    from tornado import gen
    from tornado.ioloop import IOLoop
    from tornado.locks import Semaphore

    sem = Semaphore(2)

    @gen.coroutine
    def worker(worker_id):
        yield sem.acquire()
        try:
            print("Worker %d is working" % worker_id)
            yield use_some_resource()
        finally:
            print("Worker %d is done" % worker_id)
            sem.release()

    @gen.coroutine
    def runner():
        # Join all workers.
        yield [worker(i) for i in range(3)]

    IOLoop.current().run_sync(runner)

    Worker 0 is working
    Worker 1 is working
    Worker 0 is done
    Worker 2 is working
    Worker 1 is done
    Worker 2 is done

    Workers 0 和 1 允许并行运行, 但是worker 2将等待直到信号量被worker 0释放.

    acquire 是一个上下文管理器, 所以 worker 可以被写为:

    @gen.coroutine
    def worker(worker_id):
        with (yield sem.acquire()):
            print("Worker %d is working" % worker_id)
            yield use_some_resource()

        # Now the semaphore has been released.
        print("Worker %d is done" % worker_id)

    在 Python 3.5 中, 信号量自身可以作为一个异步上下文管理器:

    async def worker(worker_id):
        async with sem:
            print("Worker %d is working" % worker_id)
            await use_some_resource()

        # Now the semaphore has been released.
        print("Worker %d is done" % worker_id)

    在 4.3 版更改: 添加对 Python 3.5 async with 的支持.

    release()[源代码]¶

        增加counter 并且唤醒一个waiter.

    acquire(timeout=None)[源代码]¶

        递减计数器. 返回一个 Future 对象.

        如果计数器(counter)为0将会阻塞, 等待 release. 在超时之后 Future 对象将会抛出
        TimeoutError .

BoundedSemaphore¶

class tornado.locks.BoundedSemaphore(value=1)[源代码]¶

    一个防止release() 被调用太多次的信号量.

    如果 release 增加信号量的值超过初始值, 它将抛出 ValueError. 信号量通常是通过限制容量来保护资
    源, 所以一个信号量释放太多次是一个错误的标志.

    release()[源代码]¶

        增加counter 并且唤醒一个waiter.

    acquire(timeout=None)¶

        递减计数器. 返回一个 Future 对象.

        如果计数器(counter)为0将会阻塞, 等待 release. 在超时之后 Future 对象将会抛出
        TimeoutError .

Lock¶

class tornado.locks.Lock[源代码]¶

    协程的锁.

    一个Lock开始解锁, 然后它立即 acquire 锁. 虽然它是锁着的, 一个协程yield acquire 并等待, 直到
    另一个协程调用 release.

    释放一个没锁住的锁将抛出 RuntimeError.

    在所有Python 版本中 acquire 支持上下文管理协议:

    >>> from tornado import gen, locks
    >>> lock = locks.Lock()
    >>>
    >>> @gen.coroutine
    ... def f():
    ...    with (yield lock.acquire()):
    ...        # Do something holding the lock.
    ...        pass
    ...
    ...    # Now the lock is released.

    在Python 3.5, Lock 也支持异步上下文管理协议(async context manager protocol). 注意在这种情况
    下没有 acquire, 因为 async with 同时包含 yield 和 acquire (就像 threading.Lock):

    >>> async def f():
    ...    async with lock:
    ...        # Do something holding the lock.
    ...        pass
    ...
    ...    # Now the lock is released.

    在 3.5 版更改: 添加Python 3.5 的 async with 支持.

    acquire(timeout=None)[源代码]¶

        尝试锁. 返回一个Future 对象.

        返回一个Future 对象, 在超时之后将抛出 tornado.gen.TimeoutError .

    release()[源代码]¶

        Unlock.

        在队列中等待 acquire 的第一个 coroutine 获得锁.

        如果没有锁, 将抛出 RuntimeError.

tornado.queues – 协程的队列¶

4.2 新版功能.

Classes¶

Queue¶

class tornado.queues.Queue(maxsize=0)[源代码]¶

    协调生产者消费者协程.

    如果maxsize 是0(默认配置)意味着队列的大小是无限的.

    from tornado import gen
    from tornado.ioloop import IOLoop
    from tornado.queues import Queue

    q = Queue(maxsize=2)

    @gen.coroutine
    def consumer():
        while True:
            item = yield q.get()
            try:
                print('Doing work on %s' % item)
                yield gen.sleep(0.01)
            finally:
                q.task_done()

    @gen.coroutine
    def producer():
        for item in range(5):
            yield q.put(item)
            print('Put %s' % item)

    @gen.coroutine
    def main():
        # Start consumer without waiting (since it never finishes).
        IOLoop.current().spawn_callback(consumer)
        yield producer()     # Wait for producer to put all tasks.
        yield q.join()       # Wait for consumer to finish all tasks.
        print('Done')

    IOLoop.current().run_sync(main)

    Put 0
    Put 1
    Doing work on 0
    Put 2
    Doing work on 1
    Put 3
    Doing work on 2
    Put 4
    Doing work on 3
    Doing work on 4
    Done

    在Python 3.5, Queue 实现了异步迭代器协议, 所以 consumer() 可以被重写为:

    async def consumer():
        async for item in q:
            try:
                print('Doing work on %s' % item)
                yield gen.sleep(0.01)
            finally:
                q.task_done()

    在 4.3 版更改: 为Python 3.5添加 async for 支持 in Python 3.5.

    maxsize¶

        队列中允许的最大项目数.

    qsize()[源代码]¶

        当前队列中的项目数.

    put(item, timeout=None)[源代码]¶

        将一个项目放入队列中, 可能需要等待直到队列中有空间.

        返回一个Future对象, 如果超时会抛出 tornado.gen.TimeoutError .

    put_nowait(item)[源代码]¶

        非阻塞的将一个项目放入队列中.

        如果没有立即可用的空闲插槽, 则抛出 QueueFull.

    get(timeout=None)[源代码]¶

        从队列中删除并返回一个项目.

        返回一个Future对象, 当项目可用时resolve, 或者在超时后抛出 tornado.gen.TimeoutError .

    get_nowait()[源代码]¶

        非阻塞的从队列中删除并返回一个项目.

        如果有项目是立即可用的则返回该项目, 否则抛出 QueueEmpty.

    task_done()[源代码]¶

        表明前面排队的任务已经完成.

        被消费者队列使用. 每个 get 用来获取一个任务, 随后(subsequent) 调用 task_done 告诉队列正
        在处理的任务已经完成.

        如果 join 正在阻塞, 它会在所有项目都被处理完后调起; 即当每个 put 都被一个 task_done 匹
        配.

        如果调用次数超过 put 将会抛出 ValueError .

    join(timeout=None)[源代码]¶

        阻塞(block)直到队列中的所有项目都处理完.

        返回一个Future对象, 超时后会抛出 tornado.gen.TimeoutError 异常.

PriorityQueue¶

class tornado.queues.PriorityQueue(maxsize=0)[源代码]¶

    一个有优先级的 Queue 最小的最优先.

    写入的条目通常是元组, 类似 (priority number, data).

    from tornado.queues import PriorityQueue

    q = PriorityQueue()
    q.put((1, 'medium-priority item'))
    q.put((0, 'high-priority item'))
    q.put((10, 'low-priority item'))

    print(q.get_nowait())
    print(q.get_nowait())
    print(q.get_nowait())

    (0, 'high-priority item')
    (1, 'medium-priority item')
    (10, 'low-priority item')

LifoQueue¶

class tornado.queues.LifoQueue(maxsize=0)[源代码]¶

    一个后进先出(Lifo)的 Queue.

    from tornado.queues import LifoQueue

    q = LifoQueue()
    q.put(3)
    q.put(2)
    q.put(1)

    print(q.get_nowait())
    print(q.get_nowait())
    print(q.get_nowait())

    1
    2
    3

Exceptions¶

QueueEmpty¶

exception tornado.queues.QueueEmpty[源代码]¶

    当队列中没有项目时, 由 Queue.get_nowait 抛出.

QueueFull¶

exception tornado.queues.QueueFull[源代码]¶

    当队列为最大size时, 由 Queue.put_nowait 抛出.

tornado.process — Utilities for multiple processes¶

Utilities for working with multiple processes, including both forking the server into multiple
processes and managing subprocesses.

exception tornado.process.CalledProcessError[源代码]¶

    An alias for subprocess.CalledProcessError.

tornado.process.cpu_count()[源代码]¶

    Returns the number of processors on this machine.

tornado.process.fork_processes(num_processes, max_restarts=100)[源代码]¶

    Starts multiple worker processes.

    If num_processes is None or <= 0, we detect the number of cores available on this machine
    and fork that number of child processes. If num_processes is given and > 0, we fork that
    specific number of sub-processes.

    Since we use processes and not threads, there is no shared memory between any server code.

    Note that multiple processes are not compatible with the autoreload module (or the 
    autoreload=True option to tornado.web.Application which defaults to True when debug=True).
    When using multiple processes, no IOLoops can be created or referenced until after the call
    to fork_processes.

    In each child process, fork_processes returns its task id, a number between 0 and 
    num_processes. Processes that exit abnormally (due to a signal or non-zero exit status) are
    restarted with the same id (up to max_restarts times). In the parent process, fork_processes
    returns None if all child processes have exited normally, but will otherwise only exit by
    throwing an exception.

tornado.process.task_id()[源代码]¶

    Returns the current task id, if any.

    Returns None if this process was not created by fork_processes.

class tornado.process.Subprocess(*args, **kwargs)[源代码]¶

    Wraps subprocess.Popen with IOStream support.

    The constructor is the same as subprocess.Popen with the following additions:

      □ stdin, stdout, and stderr may have the value tornado.process.Subprocess.STREAM, which
        will make the corresponding attribute of the resulting Subprocess a PipeIOStream.
      □ A new keyword argument io_loop may be used to pass in an IOLoop.

    在 4.1 版更改: The io_loop argument is deprecated.

    set_exit_callback(callback)[源代码]¶

        Runs callback when this process exits.

        The callback takes one argument, the return code of the process.

        This method uses a SIGCHLD handler, which is a global setting and may conflict if you
        have other libraries trying to handle the same signal. If you are using more than one 
        IOLoop it may be necessary to call Subprocess.initialize first to designate one IOLoop
        to run the signal handlers.

        In many cases a close callback on the stdout or stderr streams can be used as an
        alternative to an exit callback if the signal handler is causing a problem.

    wait_for_exit(raise_error=True)[源代码]¶

        Returns a Future which resolves when the process exits.

        Usage:

        ret = yield proc.wait_for_exit()

        This is a coroutine-friendly alternative to set_exit_callback (and a replacement for the
        blocking subprocess.Popen.wait).

        By default, raises subprocess.CalledProcessError if the process has a non-zero exit
        status. Use wait_for_exit(raise_error=False) to suppress this behavior and return the
        exit status without raising.

        4.2 新版功能.

    classmethod initialize(io_loop=None)[源代码]¶

        Initializes the SIGCHLD handler.

        The signal handler is run on an IOLoop to avoid locking issues. Note that the IOLoop
        used for signal handling need not be the same one used by individual Subprocess objects
        (as long as the IOLoops are each running in separate threads).

        在 4.1 版更改: The io_loop argument is deprecated.

    classmethod uninitialize()[源代码]¶

        Removes the SIGCHLD handler.

与其他服务集成¶

tornado.auth — Third-party login with OpenID and OAuth¶

This module contains implementations of various third-party authentication schemes.

All the classes in this file are class mixins designed to be used with the
tornado.web.RequestHandler class. They are used in two ways:

  • On a login handler, use methods such as authenticate_redirect(), authorize_redirect(), and 
    get_authenticated_user() to establish the user’s identity and store authentication tokens to
    your database and/or cookies.
  • In non-login handlers, use methods such as facebook_request() or twitter_request() to use
    the authentication tokens to make requests to the respective services.

They all take slightly different arguments due to the fact all these services implement
authentication and authorization slightly differently. See the individual service classes below
for complete documentation.

Example usage for Google OAuth:

class GoogleOAuth2LoginHandler(tornado.web.RequestHandler,
                               tornado.auth.GoogleOAuth2Mixin):
    @tornado.gen.coroutine
    def get(self):
        if self.get_argument('code', False):
            user = yield self.get_authenticated_user(
                redirect_uri='http://your.site.com/auth/google',
                code=self.get_argument('code'))
            # Save the user with e.g. set_secure_cookie
        else:
            yield self.authorize_redirect(
                redirect_uri='http://your.site.com/auth/google',
                client_id=self.settings['google_oauth']['key'],
                scope=['profile', 'email'],
                response_type='code',
                extra_params={'approval_prompt': 'auto'})

在 4.0 版更改: All of the callback interfaces in this module are now guaranteed to run their
callback with an argument of None on error. Previously some functions would do this while others
would simply terminate the request on their own. This change also ensures that errors are more
consistently reported through the Future interfaces.

Common protocols¶

These classes implement the OpenID and OAuth standards. They will generally need to be
subclassed to use them with any particular site. The degree of customization required will vary,
but in most cases overridding the class attributes (which are named beginning with underscores
for historical reasons) should be sufficient.

class tornado.auth.OpenIdMixin[源代码]¶

    Abstract implementation of OpenID and Attribute Exchange.

    Class attributes:

      □ _OPENID_ENDPOINT: the identity provider’s URI.

    authenticate_redirect(callback_uri=None, ax_attrs=['name', 'email', 'language', 'username'],
        callback=None)[源代码]¶

        Redirects to the authentication URL for this service.

        After authentication, the service will redirect back to the given callback URI with
        additional parameters including openid.mode.

        We request the given attributes for the authenticated user by default (name, email,
        language, and username). If you don’t need all those attributes for your app, you can
        request fewer with the ax_attrs keyword argument.

        在 3.1 版更改: Returns a Future and takes an optional callback. These are not strictly
        necessary as this method is synchronous, but they are supplied for consistency with
        OAuthMixin.authorize_redirect.

    get_authenticated_user(callback, http_client=None)[源代码]¶

        Fetches the authenticated user data upon redirect.

        This method should be called by the handler that receives the redirect from the
        authenticate_redirect() method (which is often the same as the one that calls it; in
        that case you would call get_authenticated_user if the openid.mode parameter is present
        and authenticate_redirect if it is not).

        The result of this method will generally be used to set a cookie.

    get_auth_http_client()[源代码]¶

        Returns the AsyncHTTPClient instance to be used for auth requests.

        May be overridden by subclasses to use an HTTP client other than the default.

class tornado.auth.OAuthMixin[源代码]¶

    Abstract implementation of OAuth 1.0 and 1.0a.

    See TwitterMixin below for an example implementation.

    Class attributes:

      □ _OAUTH_AUTHORIZE_URL: The service’s OAuth authorization url.
      □ _OAUTH_ACCESS_TOKEN_URL: The service’s OAuth access token url.
      □ _OAUTH_VERSION: May be either “1.0” or “1.0a”.
      □ _OAUTH_NO_CALLBACKS: Set this to True if the service requires advance registration of
        callbacks.

    Subclasses must also override the _oauth_get_user_future and _oauth_consumer_token methods.

    authorize_redirect(callback_uri=None, extra_params=None, http_client=None, callback=None)[源
        代码]¶

        Redirects the user to obtain OAuth authorization for this service.

        The callback_uri may be omitted if you have previously registered a callback URI with
        the third-party service. For some services (including Friendfeed), you must use a
        previously-registered callback URI and cannot specify a callback via this method.

        This method sets a cookie called _oauth_request_token which is subsequently used (and
        cleared) in get_authenticated_user for security purposes.

        Note that this method is asynchronous, although it calls RequestHandler.finish for you
        so it may not be necessary to pass a callback or use the Future it returns. However, if
        this method is called from a function decorated with gen.coroutine, you must call it
        with yield to keep the response from being closed prematurely.

        在 3.1 版更改: Now returns a Future and takes an optional callback, for compatibility
        with gen.coroutine.

    get_authenticated_user(callback, http_client=None)[源代码]¶

        Gets the OAuth authorized user and access token.

        This method should be called from the handler for your OAuth callback URL to complete
        the registration process. We run the callback with the authenticated user dictionary.
        This dictionary will contain an access_key which can be used to make authorized requests
        to this service on behalf of the user. The dictionary will also contain other fields
        such as name, depending on the service used.

    _oauth_consumer_token()[源代码]¶

        Subclasses must override this to return their OAuth consumer keys.

        The return value should be a dict with keys key and secret.

    _oauth_get_user_future(access_token, callback)[源代码]¶

        Subclasses must override this to get basic information about the user.

        Should return a Future whose result is a dictionary containing information about the
        user, which may have been retrieved by using access_token to make a request to the
        service.

        The access token will be added to the returned dictionary to make the result of
        get_authenticated_user.

        For backwards compatibility, the callback-based _oauth_get_user method is also
        supported.

    get_auth_http_client()[源代码]¶

        Returns the AsyncHTTPClient instance to be used for auth requests.

        May be overridden by subclasses to use an HTTP client other than the default.

class tornado.auth.OAuth2Mixin[源代码]¶

    Abstract implementation of OAuth 2.0.

    See FacebookGraphMixin or GoogleOAuth2Mixin below for example implementations.

    Class attributes:

      □ _OAUTH_AUTHORIZE_URL: The service’s authorization url.
      □ _OAUTH_ACCESS_TOKEN_URL: The service’s access token url.

    authorize_redirect(redirect_uri=None, client_id=None, client_secret=None, extra_params=None,
        callback=None, scope=None, response_type='code')[源代码]¶

        Redirects the user to obtain OAuth authorization for this service.

        Some providers require that you register a redirect URL with your application instead of
        passing one via this method. You should call this method to log the user in, and then
        call get_authenticated_user in the handler for your redirect URL to complete the
        authorization process.

        在 3.1 版更改: Returns a Future and takes an optional callback. These are not strictly
        necessary as this method is synchronous, but they are supplied for consistency with
        OAuthMixin.authorize_redirect.

    oauth2_request(url, callback, access_token=None, post_args=None, **args)[源代码]¶

        Fetches the given URL auth an OAuth2 access token.

        If the request is a POST, post_args should be provided. Query string arguments should be
        given as keyword arguments.

        Example usage:

        ..testcode:

        class MainHandler(tornado.web.RequestHandler,
                          tornado.auth.FacebookGraphMixin):
            @tornado.web.authenticated
            @tornado.gen.coroutine
            def get(self):
                new_entry = yield self.oauth2_request(
                    "https://graph.facebook.com/me/feed",
                    post_args={"message": "I am posting from my Tornado application!"},
                    access_token=self.current_user["access_token"])

                if not new_entry:
                    # Call failed; perhaps missing permission?
                    yield self.authorize_redirect()
                    return
                self.finish("Posted a message!")

        4.3 新版功能.

    get_auth_http_client()[源代码]¶

        Returns the AsyncHTTPClient instance to be used for auth requests.

        May be overridden by subclasses to use an HTTP client other than the default.

        4.3 新版功能.

Google¶

class tornado.auth.GoogleOAuth2Mixin[源代码]¶

    Google authentication using OAuth2.

    In order to use, register your application with Google and copy the relevant parameters to
    your application settings.

      □ Go to the Google Dev Console at http://console.developers.google.com
      □ Select a project, or create a new one.
      □ In the sidebar on the left, select APIs & Auth.
      □ In the list of APIs, find the Google+ API service and set it to ON.
      □ In the sidebar on the left, select Credentials.
      □ In the OAuth section of the page, select Create New Client ID.
      □ Set the Redirect URI to point to your auth handler
      □ Copy the “Client secret” and “Client ID” to the application settings as {“google_oauth”:
        {“key”: CLIENT_ID, “secret”: CLIENT_SECRET}}

    3.2 新版功能.

    get_authenticated_user(redirect_uri, code, callback)[源代码]¶

        Handles the login for the Google user, returning an access token.

        The result is a dictionary containing an access_token field ([among others](https://
        developers.google.com/identity/protocols/OAuth2WebServer#handlingtheresponse)). Unlike
        other get_authenticated_user methods in this package, this method does not return any
        additional information about the user. The returned access token can be used with
        OAuth2Mixin.oauth2_request to request additional information (perhaps from https://
        www.googleapis.com/oauth2/v2/userinfo)

        Example usage:

        class GoogleOAuth2LoginHandler(tornado.web.RequestHandler,
                                       tornado.auth.GoogleOAuth2Mixin):
            @tornado.gen.coroutine
            def get(self):
                if self.get_argument('code', False):
                    access = yield self.get_authenticated_user(
                        redirect_uri='http://your.site.com/auth/google',
                        code=self.get_argument('code'))
                    user = yield self.oauth2_request(
                        "https://www.googleapis.com/oauth2/v1/userinfo",
                        access_token=access["access_token"])
                    # Save the user and access token with
                    # e.g. set_secure_cookie.
                else:
                    yield self.authorize_redirect(
                        redirect_uri='http://your.site.com/auth/google',
                        client_id=self.settings['google_oauth']['key'],
                        scope=['profile', 'email'],
                        response_type='code',
                        extra_params={'approval_prompt': 'auto'})

Facebook¶

class tornado.auth.FacebookGraphMixin[源代码]¶

    Facebook authentication using the new Graph API and OAuth2.

    get_authenticated_user(redirect_uri, client_id, client_secret, code, callback, extra_fields=
        None)[源代码]¶

        Handles the login for the Facebook user, returning a user object.

        Example usage:

        class FacebookGraphLoginHandler(tornado.web.RequestHandler,
                                        tornado.auth.FacebookGraphMixin):
          @tornado.gen.coroutine
          def get(self):
              if self.get_argument("code", False):
                  user = yield self.get_authenticated_user(
                      redirect_uri='/auth/facebookgraph/',
                      client_id=self.settings["facebook_api_key"],
                      client_secret=self.settings["facebook_secret"],
                      code=self.get_argument("code"))
                  # Save the user with e.g. set_secure_cookie
              else:
                  yield self.authorize_redirect(
                      redirect_uri='/auth/facebookgraph/',
                      client_id=self.settings["facebook_api_key"],
                      extra_params={"scope": "read_stream,offline_access"})

    facebook_request(path, callback, access_token=None, post_args=None, **args)[源代码]¶

        Fetches the given relative API path, e.g., “/btaylor/picture”

        If the request is a POST, post_args should be provided. Query string arguments should be
        given as keyword arguments.

        An introduction to the Facebook Graph API can be found at http://developers.facebook.com
        /docs/api

        Many methods require an OAuth access token which you can obtain through
        authorize_redirect and get_authenticated_user. The user returned through that process
        includes an access_token attribute that can be used to make authenticated requests via
        this method.

        Example usage:

        ..testcode:

        class MainHandler(tornado.web.RequestHandler,
                          tornado.auth.FacebookGraphMixin):
            @tornado.web.authenticated
            @tornado.gen.coroutine
            def get(self):
                new_entry = yield self.facebook_request(
                    "/me/feed",
                    post_args={"message": "I am posting from my Tornado application!"},
                    access_token=self.current_user["access_token"])

                if not new_entry:
                    # Call failed; perhaps missing permission?
                    yield self.authorize_redirect()
                    return
                self.finish("Posted a message!")

        The given path is relative to self._FACEBOOK_BASE_URL, by default “https://
        graph.facebook.com”.

        This method is a wrapper around OAuth2Mixin.oauth2_request; the only difference is that
        this method takes a relative path, while oauth2_request takes a complete url.

        在 3.1 版更改: Added the ability to override self._FACEBOOK_BASE_URL.

Twitter¶

class tornado.auth.TwitterMixin[源代码]¶

    Twitter OAuth authentication.

    To authenticate with Twitter, register your application with Twitter at http://twitter.com/
    apps. Then copy your Consumer Key and Consumer Secret to the application settings 
    twitter_consumer_key and twitter_consumer_secret. Use this mixin on the handler for the URL
    you registered as your application’s callback URL.

    When your application is set up, you can use this mixin like this to authenticate the user
    with Twitter and get access to their stream:

    class TwitterLoginHandler(tornado.web.RequestHandler,
                              tornado.auth.TwitterMixin):
        @tornado.gen.coroutine
        def get(self):
            if self.get_argument("oauth_token", None):
                user = yield self.get_authenticated_user()
                # Save the user using e.g. set_secure_cookie()
            else:
                yield self.authorize_redirect()

    The user object returned by get_authenticated_user includes the attributes username, name, 
    access_token, and all of the custom Twitter user attributes described at https://
    dev.twitter.com/docs/api/1.1/get/users/show

    authenticate_redirect(callback_uri=None, callback=None)[源代码]¶

        Just like authorize_redirect, but auto-redirects if authorized.

        This is generally the right interface to use if you are using Twitter for single-sign
        on.

        在 3.1 版更改: Now returns a Future and takes an optional callback, for compatibility
        with gen.coroutine.

    twitter_request(path, callback=None, access_token=None, post_args=None, **args)[源代码]¶

        Fetches the given API path, e.g., statuses/user_timeline/btaylor

        The path should not include the format or API version number. (we automatically use JSON
        format and API version 1).

        If the request is a POST, post_args should be provided. Query string arguments should be
        given as keyword arguments.

        All the Twitter methods are documented at http://dev.twitter.com/

        Many methods require an OAuth access token which you can obtain through
        authorize_redirect and get_authenticated_user. The user returned through that process
        includes an ‘access_token’ attribute that can be used to make authenticated requests via
        this method. Example usage:

        class MainHandler(tornado.web.RequestHandler,
                          tornado.auth.TwitterMixin):
            @tornado.web.authenticated
            @tornado.gen.coroutine
            def get(self):
                new_entry = yield self.twitter_request(
                    "/statuses/update",
                    post_args={"status": "Testing Tornado Web Server"},
                    access_token=self.current_user["access_token"])
                if not new_entry:
                    # Call failed; perhaps missing permission?
                    yield self.authorize_redirect()
                    return
                self.finish("Posted a message!")

tornado.wsgi — Interoperability with other Python frameworks and servers¶

WSGI support for the Tornado web framework.

WSGI is the Python standard for web servers, and allows for interoperability between Tornado and
other Python web frameworks and servers. This module provides WSGI support in two ways:

  • WSGIAdapter converts a tornado.web.Application to the WSGI application interface. This is
    useful for running a Tornado app on another HTTP server, such as Google App Engine. See the
    WSGIAdapter class documentation for limitations that apply.
  • WSGIContainer lets you run other WSGI applications and frameworks on the Tornado HTTP
    server. For example, with this class you can mix Django and Tornado handlers in a single
    server.

Running Tornado apps on WSGI servers¶

class tornado.wsgi.WSGIAdapter(application)[源代码]¶

    Converts a tornado.web.Application instance into a WSGI application.

    Example usage:

    import tornado.web
    import tornado.wsgi
    import wsgiref.simple_server

    class MainHandler(tornado.web.RequestHandler):
        def get(self):
            self.write("Hello, world")

    if __name__ == "__main__":
        application = tornado.web.Application([
            (r"/", MainHandler),
        ])
        wsgi_app = tornado.wsgi.WSGIAdapter(application)
        server = wsgiref.simple_server.make_server('', 8888, wsgi_app)
        server.serve_forever()

    See the appengine demo for an example of using this module to run a Tornado app on Google
    App Engine.

    In WSGI mode asynchronous methods are not supported. This means that it is not possible to
    use AsyncHTTPClient, or the tornado.auth or tornado.websocket modules.

    4.0 新版功能.

class tornado.wsgi.WSGIApplication(handlers=None, default_host='', transforms=None, **settings)
    [源代码]¶

    A WSGI equivalent of tornado.web.Application.

    4.0 版后已移除: Use a regular Application and wrap it in WSGIAdapter instead.

Running WSGI apps on Tornado servers¶

class tornado.wsgi.WSGIContainer(wsgi_application)[源代码]¶

    Makes a WSGI-compatible function runnable on Tornado’s HTTP server.

    警告

    WSGI is a synchronous interface, while Tornado’s concurrency model is based on
    single-threaded asynchronous execution. This means that running a WSGI app with Tornado’s
    WSGIContainer is less scalable than running the same app in a multi-threaded WSGI server
    like gunicorn or uwsgi. Use WSGIContainer only when there are benefits to combining Tornado
    and WSGI in the same process that outweigh the reduced scalability.

    Wrap a WSGI function in a WSGIContainer and pass it to HTTPServer to run it. For example:

    def simple_app(environ, start_response):
        status = "200 OK"
        response_headers = [("Content-type", "text/plain")]
        start_response(status, response_headers)
        return ["Hello world!\n"]

    container = tornado.wsgi.WSGIContainer(simple_app)
    http_server = tornado.httpserver.HTTPServer(container)
    http_server.listen(8888)
    tornado.ioloop.IOLoop.current().start()

    This class is intended to let other frameworks (Django, web.py, etc) run on the Tornado HTTP
    server and I/O loop.

    The tornado.web.FallbackHandler class is often useful for mixing Tornado and WSGI apps in
    the same server. See https://github.com/bdarnell/django-tornado-demo for a complete example.

    static environ(request)[源代码]¶

        Converts a tornado.httputil.HTTPServerRequest to a WSGI environment.

tornado.platform.asyncio — Bridge between asyncio and Tornado¶

Bridges between the asyncio module and Tornado IOLoop.

3.2 新版功能.

This module integrates Tornado with the asyncio module introduced in Python 3.4 (and available
as a separate download for Python 3.3). This makes it possible to combine the two libraries on
the same event loop.

Most applications should use AsyncIOMainLoop to run Tornado on the default asyncio event loop.
Applications that need to run event loops on multiple threads may use AsyncIOLoop to create
multiple loops.

注解

Tornado requires the add_reader family of methods, so it is not compatible with the
ProactorEventLoop on Windows. Use the SelectorEventLoop instead.

class tornado.platform.asyncio.AsyncIOMainLoop[源代码]¶

    AsyncIOMainLoop creates an IOLoop that corresponds to the current asyncio event loop (i.e.
    the one returned by asyncio.get_event_loop()). Recommended usage:

    from tornado.platform.asyncio import AsyncIOMainLoop
    import asyncio
    AsyncIOMainLoop().install()
    asyncio.get_event_loop().run_forever()

class tornado.platform.asyncio.AsyncIOLoop[源代码]¶

    AsyncIOLoop is an IOLoop that runs on an asyncio event loop. This class follows the usual
    Tornado semantics for creating new IOLoops; these loops are not necessarily related to the 
    asyncio default event loop. Recommended usage:

    from tornado.ioloop import IOLoop
    IOLoop.configure('tornado.platform.asyncio.AsyncIOLoop')
    IOLoop.current().start()

    Each AsyncIOLoop creates a new asyncio.EventLoop; this object can be accessed with the 
    asyncio_loop attribute.

tornado.platform.asyncio.to_tornado_future(asyncio_future)[源代码]¶

    Convert an asyncio.Future to a tornado.concurrent.Future.

    4.1 新版功能.

tornado.platform.asyncio.to_asyncio_future(tornado_future)[源代码]¶

    Convert a Tornado yieldable object to an asyncio.Future.

    4.1 新版功能.

    在 4.3 版更改: Now accepts any yieldable object, not just tornado.concurrent.Future.

tornado.platform.caresresolver — Asynchronous DNS Resolver using C-Ares¶

This module contains a DNS resolver using the c-ares library (and its wrapper pycares).

class tornado.platform.caresresolver.CaresResolver¶

    Name resolver based on the c-ares library.

    This is a non-blocking and non-threaded resolver. It may not produce the same results as the
    system resolver, but can be used for non-blocking resolution when threads cannot be used.

    c-ares fails to resolve some names when family is AF_UNSPEC, so it is only recommended for
    use in AF_INET (i.e. IPv4). This is the default for tornado.simple_httpclient, but other
    libraries may default to AF_UNSPEC.

tornado.platform.twisted — Bridges between Twisted and Tornado¶

Bridges between the Twisted reactor and Tornado IOLoop.

This module lets you run applications and libraries written for Twisted in a Tornado
application. It can be used in two modes, depending on which library’s underlying event loop you
want to use.

This module has been tested with Twisted versions 11.0.0 and newer.

Twisted on Tornado¶

class tornado.platform.twisted.TornadoReactor(io_loop=None)[源代码]¶

    Twisted reactor built on the Tornado IOLoop.

    TornadoReactor implements the Twisted reactor interface on top of the Tornado IOLoop. To use
    it, simply call install at the beginning of the application:

    import tornado.platform.twisted
    tornado.platform.twisted.install()
    from twisted.internet import reactor

    When the app is ready to start, call IOLoop.current().start() instead of reactor.run().

    It is also possible to create a non-global reactor by calling 
    tornado.platform.twisted.TornadoReactor(io_loop). However, if the IOLoop and reactor are to
    be short-lived (such as those used in unit tests), additional cleanup may be required.
    Specifically, it is recommended to call:

    reactor.fireSystemEvent('shutdown')
    reactor.disconnectAll()

    before closing the IOLoop.

    在 4.1 版更改: The io_loop argument is deprecated.

tornado.platform.twisted.install(io_loop=None)[源代码]¶

    Install this package as the default Twisted reactor.

    install() must be called very early in the startup process, before most other
    twisted-related imports. Conversely, because it initializes the IOLoop, it cannot be called
    before fork_processes or multi-process start. These conflicting requirements make it
    difficult to use TornadoReactor in multi-process mode, and an external process manager such
    as supervisord is recommended instead.

    在 4.1 版更改: The io_loop argument is deprecated.

Tornado on Twisted¶

class tornado.platform.twisted.TwistedIOLoop[源代码]¶

    IOLoop implementation that runs on Twisted.

    TwistedIOLoop implements the Tornado IOLoop interface on top of the Twisted reactor.
    Recommended usage:

    from tornado.platform.twisted import TwistedIOLoop
    from twisted.internet import reactor
    TwistedIOLoop().install()
    # Set up your tornado application as usual using `IOLoop.instance`
    reactor.run()

    Uses the global Twisted reactor by default. To create multiple TwistedIOLoops in the same
    process, you must pass a unique reactor when constructing each one.

    Not compatible with tornado.process.Subprocess.set_exit_callback because the SIGCHLD
    handlers used by Tornado and Twisted conflict with each other.

Twisted DNS resolver¶

class tornado.platform.twisted.TwistedResolver[源代码]¶

    Twisted-based asynchronous resolver.

    This is a non-blocking and non-threaded resolver. It is recommended only when threads cannot
    be used, since it has limitations compared to the standard getaddrinfo-based Resolver and
    ThreadedResolver. Specifically, it returns at most one result, and arguments other than host
    and family are ignored. It may fail to resolve when family is not socket.AF_UNSPEC.

    Requires Twisted 12.1 or newer.

    在 4.1 版更改: The io_loop argument is deprecated.

通用工具¶

tornado.autoreload — Automatically detect code changes in development¶

Automatically restart the server when a source file is modified.

Most applications should not access this module directly. Instead, pass the keyword argument 
autoreload=True to the tornado.web.Application constructor (or debug=True, which enables this
setting and several others). This will enable autoreload mode as well as checking for changes to
templates and static resources. Note that restarting is a destructive operation and any requests
in progress will be aborted when the process restarts. (If you want to disable autoreload while
using other debug-mode features, pass both debug=True and autoreload=False).

This module can also be used as a command-line wrapper around scripts such as unit test runners.
See the main method for details.

The command-line wrapper and Application debug modes can be used together. This combination is
encouraged as the wrapper catches syntax errors and other import-time failures, while debug mode
catches changes once the server has started.

This module depends on IOLoop, so it will not work in WSGI applications and Google App Engine.
It also will not work correctly when HTTPServer‘s multi-process mode is used.

Reloading loses any Python interpreter command-line arguments (e.g. -u) because it re-executes
Python using sys.executable and sys.argv. Additionally, modifying these variables will cause
reloading to behave incorrectly.

tornado.autoreload.start(io_loop=None, check_time=500)[源代码]¶

    Begins watching source files for changes.

    在 4.1 版更改: The io_loop argument is deprecated.

tornado.autoreload.wait()[源代码]¶

    Wait for a watched file to change, then restart the process.

    Intended to be used at the end of scripts like unit test runners, to run the tests again
    after any source file changes (but see also the command-line interface in main)

tornado.autoreload.watch(filename)[源代码]¶

    Add a file to the watch list.

    All imported modules are watched by default.

tornado.autoreload.add_reload_hook(fn)[源代码]¶

    Add a function to be called before reloading the process.

    Note that for open file and socket handles it is generally preferable to set the FD_CLOEXEC
    flag (using fcntl or tornado.platform.auto.set_close_exec) instead of using a reload hook to
    close them.

tornado.autoreload.main()[源代码]¶

    Command-line wrapper to re-run a script whenever its source changes.

    Scripts may be specified by filename or module name:

    python -m tornado.autoreload -m tornado.test.runtests
    python -m tornado.autoreload tornado/test/runtests.py

    Running a script with this wrapper is similar to calling tornado.autoreload.wait at the end
    of the script, but this wrapper can catch import-time problems like syntax errors that would
    otherwise prevent the script from reaching its call to wait.

tornado.log — Logging support¶

Logging support for Tornado.

Tornado uses three logger streams:

  • tornado.access: Per-request logging for Tornado’s HTTP servers (and potentially other
    servers in the future)
  • tornado.application: Logging of errors from application code (i.e. uncaught exceptions from
    callbacks)
  • tornado.general: General-purpose logging, including any errors or warnings from Tornado
    itself.

These streams may be configured independently using the standard library’s logging module. For
example, you may wish to send tornado.access logs to a separate file for analysis.

class tornado.log.LogFormatter(color=True, fmt='%(color)s[%(levelname)1.1s %(asctime)s %(module)
    s:%(lineno)d]%(end_color)s %(message)s', datefmt='%y%m%d %H:%M:%S', colors={40: 1, 10: 4, 
    20: 2, 30: 3})[源代码]¶

    Log formatter used in Tornado.

    Key features of this formatter are:

      □ Color support when logging to a terminal that supports it.
      □ Timestamps on every log line.
      □ Robust against str/bytes encoding problems.

    This formatter is enabled automatically by tornado.options.parse_command_line (unless 
    --logging=none is used).

          • color (bool) – Enables color support.
          • fmt (string) – Log message format. It will be applied to the attributes dict of log
    参      records. The text between %(color)s and %(end_color)s will be colored depending on
    数:     the level if color support is on.
          • colors (dict) – color mappings from logging level to terminal color code
          • datefmt (string) – Datetime format. Used for formatting (asctime) placeholder in 
            prefix_fmt.

    在 3.2 版更改: Added fmt and datefmt arguments.

tornado.log.enable_pretty_logging(options=None, logger=None)[源代码]¶

    Turns on formatted logging output as configured.

    This is called automatically by tornado.options.parse_command_line and
    tornado.options.parse_config_file.

tornado.log.define_logging_options(options=None)[源代码]¶

    Add logging-related flags to options.

    These options are present automatically on the default options instance; this method is only
    necessary if you have created your own OptionParser.

    4.2 新版功能: This function existed in prior versions but was broken and undocumented until
    4.2.

tornado.options — Command-line parsing¶

A command line parsing module that lets modules define their own options.

Each module defines its own options which are added to the global option namespace, e.g.:

from tornado.options import define, options

define("mysql_host", default="127.0.0.1:3306", help="Main user DB")
define("memcache_hosts", default="127.0.0.1:11011", multiple=True,
       help="Main user memcache servers")

def connect():
    db = database.Connection(options.mysql_host)
    ...

The main() method of your application does not need to be aware of all of the options used
throughout your program; they are all automatically loaded when the modules are loaded. However,
all modules that define options must have been imported before the command line is parsed.

Your main() method can parse the command line or parse a config file with either:

tornado.options.parse_command_line()
# or
tornado.options.parse_config_file("/etc/server.conf")

Command line formats are what you would expect (--myoption=myvalue). Config files are just
Python files. Global names become options, e.g.:

myoption = "myvalue"
myotheroption = "myothervalue"

We support datetimes, timedeltas, ints, and floats (just pass a type kwarg to define). We also
accept multi-value options. See the documentation for define() below.

tornado.options.options is a singleton instance of OptionParser, and the top-level functions in
this module (define, parse_command_line, etc) simply call methods on it. You may create
additional OptionParser instances to define isolated sets of options, such as for subcommands.

注解

By default, several options are defined that will configure the standard logging module when
parse_command_line or parse_config_file are called. If you want Tornado to leave the logging
configuration alone so you can manage it yourself, either pass --logging=none on the command
line or do the following to disable it in code:

from tornado.options import options, parse_command_line
options.logging = None
parse_command_line()

在 4.3 版更改: Dashes and underscores are fully interchangeable in option names; options can be
defined, set, and read with any mix of the two. Dashes are typical for command-line usage while
config files require underscores.

Global functions¶

tornado.options.define(name, default=None, type=None, help=None, metavar=None, multiple=False, 
    group=None, callback=None)[源代码]¶

    Defines an option in the global namespace.

    See OptionParser.define.

tornado.options.options¶

    Global options object. All defined options are available as attributes on this object.

tornado.options.parse_command_line(args=None, final=True)[源代码]¶

    Parses global options from the command line.

    See OptionParser.parse_command_line.

tornado.options.parse_config_file(path, final=True)[源代码]¶

    Parses global options from a config file.

    See OptionParser.parse_config_file.

tornado.options.print_help(file=sys.stderr)[源代码]¶

    Prints all the command line options to stderr (or another file).

    See OptionParser.print_help.

tornado.options.add_parse_callback(callback)[源代码]¶

    Adds a parse callback, to be invoked when option parsing is done.

    See OptionParser.add_parse_callback

exception tornado.options.Error[源代码]¶

    Exception raised by errors in the options module.

OptionParser class¶

class tornado.options.OptionParser[源代码]¶

    A collection of options, a dictionary with object-like access.

    Normally accessed via static functions in the tornado.options module, which reference a
    global instance.

    items()[源代码]¶

        A sequence of (name, value) pairs.

        3.1 新版功能.

    groups()[源代码]¶

        The set of option-groups created by define.

        3.1 新版功能.

    group_dict(group)[源代码]¶

        The names and values of options in a group.

        Useful for copying options into Application settings:

        from tornado.options import define, parse_command_line, options

        define('template_path', group='application')
        define('static_path', group='application')

        parse_command_line()

        application = Application(
            handlers, **options.group_dict('application'))

        3.1 新版功能.

    as_dict()[源代码]¶

        The names and values of all options.

        3.1 新版功能.

    define(name, default=None, type=None, help=None, metavar=None, multiple=False, group=None, 
        callback=None)[源代码]¶

        Defines a new command line option.

        If type is given (one of str, float, int, datetime, or timedelta) or can be inferred
        from the default, we parse the command line arguments based on the given type. If 
        multiple is True, we accept comma-separated values, and the option value is always a
        list.

        For multi-value integers, we also accept the syntax x:y, which turns into range(x, y) -
        very useful for long integer ranges.

        help and metavar are used to construct the automatically generated command line help
        string. The help message is formatted like:

        --name=METAVAR      help string

        group is used to group the defined options in logical groups. By default, command line
        options are grouped by the file in which they are defined.

        Command line option names must be unique globally. They can be parsed from the command
        line with parse_command_line or parsed from a config file with parse_config_file.

        If a callback is given, it will be run with the new value whenever the option is
        changed. This can be used to combine command-line and file-based options:

        define("config", type=str, help="path to config file",
               callback=lambda path: parse_config_file(path, final=False))

        With this definition, options in the file specified by --config will override options
        set earlier on the command line, but can be overridden by later flags.

    parse_command_line(args=None, final=True)[源代码]¶

        Parses all options given on the command line (defaults to sys.argv).

        Note that args[0] is ignored since it is the program name in sys.argv.

        We return a list of all arguments that are not parsed as options.

        If final is False, parse callbacks will not be run. This is useful for applications that
        wish to combine configurations from multiple sources.

    parse_config_file(path, final=True)[源代码]¶

        Parses and loads the Python config file at the given path.

        If final is False, parse callbacks will not be run. This is useful for applications that
        wish to combine configurations from multiple sources.

        在 4.1 版更改: Config files are now always interpreted as utf-8 instead of the system
        default encoding.

    print_help(file=None)[源代码]¶

        Prints all the command line options to stderr (or another file).

    add_parse_callback(callback)[源代码]¶

        Adds a parse callback, to be invoked when option parsing is done.

    mockable()[源代码]¶

        Returns a wrapper around self that is compatible with mock.patch.

        The mock.patch function (included in the standard library unittest.mock package since
        Python 3.3, or in the third-party mock package for older versions of Python) is
        incompatible with objects like options that override __getattr__ and __setattr__. This
        function returns an object that can be used with mock.patch.object to modify option
        values:

        with mock.patch.object(options.mockable(), 'name', value):
            assert options.name == value

tornado.stack_context — Exception handling across asynchronous callbacks¶

StackContext allows applications to maintain threadlocal-like state that follows execution as it
moves to other execution contexts.

The motivating examples are to eliminate the need for explicit async_callback wrappers (as in
tornado.web.RequestHandler), and to allow some additional context to be kept for logging.

This is slightly magic, but it’s an extension of the idea that an exception handler is a kind of
stack-local state and when that stack is suspended and resumed in a new context that state needs
to be preserved. StackContext shifts the burden of restoring that state from each call site
(e.g. wrapping each AsyncHTTPClient callback in async_callback) to the mechanisms that transfer
control from one context to another (e.g. AsyncHTTPClient itself, IOLoop, thread pools, etc).

Example usage:

@contextlib.contextmanager
def die_on_error():
    try:
        yield
    except Exception:
        logging.error("exception in asynchronous operation",exc_info=True)
        sys.exit(1)

with StackContext(die_on_error):
    # Any exception thrown here *or in callback and its descendants*
    # will cause the process to exit instead of spinning endlessly
    # in the ioloop.
    http_client.fetch(url, callback)
ioloop.start()

Most applications shouldn’t have to work with StackContext directly. Here are a few rules of
thumb for when it’s necessary:

  • If you’re writing an asynchronous library that doesn’t rely on a stack_context-aware library
    like tornado.ioloop or tornado.iostream (for example, if you’re writing a thread pool), use
    stack_context.wrap() before any asynchronous operations to capture the stack context from
    where the operation was started.
  • If you’re writing an asynchronous library that has some shared resources (such as a
    connection pool), create those shared resources within a with stack_context.NullContext():
    block. This will prevent StackContexts from leaking from one request to another.
  • If you want to write something like an exception handler that will persist across
    asynchronous calls, create a new StackContext (or ExceptionStackContext), and make your
    asynchronous calls in a with block that references your StackContext.

class tornado.stack_context.StackContext(context_factory)[源代码]¶

    Establishes the given context as a StackContext that will be transferred.

    Note that the parameter is a callable that returns a context manager, not the context
    itself. That is, where for a non-transferable context manager you would say:

    with my_context():

    StackContext takes the function itself rather than its result:

    with StackContext(my_context):

    The result of with StackContext() as cb: is a deactivation callback. Run this callback when
    the StackContext is no longer needed to ensure that it is not propagated any further (note
    that deactivating a context does not affect any instances of that context that are currently
    pending). This is an advanced feature and not necessary in most applications.

class tornado.stack_context.ExceptionStackContext(exception_handler)[源代码]¶

    Specialization of StackContext for exception handling.

    The supplied exception_handler function will be called in the event of an uncaught exception
    in this context. The semantics are similar to a try/finally clause, and intended use cases
    are to log an error, close a socket, or similar cleanup actions. The exc_info triple (type, 
    value, traceback) will be passed to the exception_handler function.

    If the exception handler returns true, the exception will be consumed and will not be
    propagated to other exception handlers.

class tornado.stack_context.NullContext[源代码]¶

    Resets the StackContext.

    Useful when creating a shared resource on demand (e.g. an AsyncHTTPClient) where the stack
    that caused the creating is not relevant to future operations.

tornado.stack_context.wrap(fn)[源代码]¶

    Returns a callable object that will restore the current StackContext when executed.

    Use this whenever saving a callback to be executed later in a different execution context
    (either in a different thread or asynchronously in the same thread).

tornado.stack_context.run_with_stack_context(context, func)[源代码]¶

    Run a coroutine func in the given StackContext.

    It is not safe to have a yield statement within a with StackContext block, so it is
    difficult to use stack context with gen.coroutine. This helper function runs the function in
    the correct context while keeping the yield and with statements syntactically separate.

    Example:

    @gen.coroutine
    def incorrect():
        with StackContext(ctx):
            # ERROR: this will raise StackContextInconsistentError
            yield other_coroutine()

    @gen.coroutine
    def correct():
        yield run_with_stack_context(StackContext(ctx), other_coroutine)

    3.1 新版功能.

tornado.testing — Unit testing support for asynchronous code¶

Support classes for automated testing.

  • AsyncTestCase and AsyncHTTPTestCase: Subclasses of unittest.TestCase with additional support
    for testing asynchronous (IOLoop based) code.
  • ExpectLog and LogTrapTestCase: Make test logs less spammy.
  • main(): A simple test runner (wrapper around unittest.main()) with support for the
    tornado.autoreload module to rerun the tests when code changes.

Asynchronous test cases¶

class tornado.testing.AsyncTestCase(methodName='runTest', **kwargs)[源代码]¶

    TestCase subclass for testing IOLoop-based asynchronous code.

    The unittest framework is synchronous, so the test must be complete by the time the test
    method returns. This means that asynchronous code cannot be used in quite the same way as
    usual. To write test functions that use the same yield-based patterns used with the
    tornado.gen module, decorate your test methods with tornado.testing.gen_test instead of
    tornado.gen.coroutine. This class also provides the stop() and wait() methods for a more
    manual style of testing. The test method itself must call self.wait(), and asynchronous
    callbacks should call self.stop() to signal completion.

    By default, a new IOLoop is constructed for each test and is available as self.io_loop. This
    IOLoop should be used in the construction of HTTP clients/servers, etc. If the code being
    tested requires a global IOLoop, subclasses should override get_new_ioloop to return it.

    The IOLoop‘s start and stop methods should not be called directly. Instead, use self.stop
    and self.wait. Arguments passed to self.stop are returned from self.wait. It is possible to
    have multiple wait/stop cycles in the same test.

    Example:

    # This test uses coroutine style.
    class MyTestCase(AsyncTestCase):
        @tornado.testing.gen_test
        def test_http_fetch(self):
            client = AsyncHTTPClient(self.io_loop)
            response = yield client.fetch("http://www.tornadoweb.org")
            # Test contents of response
            self.assertIn("FriendFeed", response.body)

    # This test uses argument passing between self.stop and self.wait.
    class MyTestCase2(AsyncTestCase):
        def test_http_fetch(self):
            client = AsyncHTTPClient(self.io_loop)
            client.fetch("http://www.tornadoweb.org/", self.stop)
            response = self.wait()
            # Test contents of response
            self.assertIn("FriendFeed", response.body)

    # This test uses an explicit callback-based style.
    class MyTestCase3(AsyncTestCase):
        def test_http_fetch(self):
            client = AsyncHTTPClient(self.io_loop)
            client.fetch("http://www.tornadoweb.org/", self.handle_fetch)
            self.wait()

        def handle_fetch(self, response):
            # Test contents of response (failures and exceptions here
            # will cause self.wait() to throw an exception and end the
            # test).
            # Exceptions thrown here are magically propagated to
            # self.wait() in test_http_fetch() via stack_context.
            self.assertIn("FriendFeed", response.body)
            self.stop()

    get_new_ioloop()[源代码]¶

        Creates a new IOLoop for this test. May be overridden in subclasses for tests that
        require a specific IOLoop (usually the singleton IOLoop.instance()).

    stop(_arg=None, **kwargs)[源代码]¶

        Stops the IOLoop, causing one pending (or future) call to wait() to return.

        Keyword arguments or a single positional argument passed to stop() are saved and will be
        returned by wait().

    wait(condition=None, timeout=None)[源代码]¶

        Runs the IOLoop until stop is called or timeout has passed.

        In the event of a timeout, an exception will be thrown. The default timeout is 5
        seconds; it may be overridden with a timeout keyword argument or globally with the 
        ASYNC_TEST_TIMEOUT environment variable.

        If condition is not None, the IOLoop will be restarted after stop() until condition()
        returns true.

        在 3.1 版更改: Added the ASYNC_TEST_TIMEOUT environment variable.

class tornado.testing.AsyncHTTPTestCase(methodName='runTest', **kwargs)[源代码]¶

    A test case that starts up an HTTP server.

    Subclasses must override get_app(), which returns the tornado.web.Application (or other
    HTTPServer callback) to be tested. Tests will typically use the provided self.http_client to
    fetch URLs from this server.

    Example, assuming the “Hello, world” example from the user guide is in hello.py:

    import hello

    class TestHelloApp(AsyncHTTPTestCase):
        def get_app(self):
            return hello.make_app()

        def test_homepage(self):
            response = self.fetch('/')
            self.assertEqual(response.code, 200)
            self.assertEqual(response.body, 'Hello, world')

    That call to self.fetch() is equivalent to

    self.http_client.fetch(self.get_url('/'), self.stop)
    response = self.wait()

    which illustrates how AsyncTestCase can turn an asynchronous operation, like 
    http_client.fetch(), into a synchronous operation. If you need to do other asynchronous
    operations in tests, you’ll probably need to use stop() and wait() yourself.

    get_app()[源代码]¶

        Should be overridden by subclasses to return a tornado.web.Application or other
        HTTPServer callback.

    fetch(path, **kwargs)[源代码]¶

        Convenience method to synchronously fetch a url.

        The given path will be appended to the local server’s host and port. Any additional
        kwargs will be passed directly to AsyncHTTPClient.fetch (and so could be used to pass 
        method="POST", body="...", etc).

    get_httpserver_options()[源代码]¶

        May be overridden by subclasses to return additional keyword arguments for the server.

    get_http_port()[源代码]¶

        Returns the port used by the server.

        A new port is chosen for each test.

    get_url(path)[源代码]¶

        Returns an absolute url for the given path on the test server.

class tornado.testing.AsyncHTTPSTestCase(methodName='runTest', **kwargs)[源代码]¶

    A test case that starts an HTTPS server.

    Interface is generally the same as AsyncHTTPTestCase.

    get_ssl_options()[源代码]¶

        May be overridden by subclasses to select SSL options.

        By default includes a self-signed testing certificate.

tornado.testing.gen_test(func=None, timeout=None)[源代码]¶

    Testing equivalent of @gen.coroutine, to be applied to test methods.

    @gen.coroutine cannot be used on tests because the IOLoop is not already running. @gen_test
    should be applied to test methods on subclasses of AsyncTestCase.

    Example:

    class MyTest(AsyncHTTPTestCase):
        @gen_test
        def test_something(self):
            response = yield gen.Task(self.fetch('/'))

    By default, @gen_test times out after 5 seconds. The timeout may be overridden globally with
    the ASYNC_TEST_TIMEOUT environment variable, or for each test with the timeout keyword
    argument:

    class MyTest(AsyncHTTPTestCase):
        @gen_test(timeout=10)
        def test_something_slow(self):
            response = yield gen.Task(self.fetch('/'))

    3.1 新版功能: The timeout argument and ASYNC_TEST_TIMEOUT environment variable.

    在 4.0 版更改: The wrapper now passes along *args, **kwargs so it can be used on functions
    with arguments.

Controlling log output¶

class tornado.testing.ExpectLog(logger, regex, required=True)[源代码]¶

    Context manager to capture and suppress expected log output.

    Useful to make tests of error conditions less noisy, while still leaving unexpected log
    entries visible. Not thread safe.

    The attribute logged_stack is set to true if any exception stack trace was logged.

    Usage:

    with ExpectLog('tornado.application', "Uncaught exception"):
        error_response = self.fetch("/some_page")

    在 4.3 版更改: Added the logged_stack attribute.

    Constructs an ExpectLog context manager.

           • logger – Logger object (or name of logger) to watch. Pass an empty string to watch
             the root logger.
     参    • regex – Regular expression to match. Any log entries on the specified logger that
    数:      match this regex will be suppressed.
           • required – If true, an exeption will be raised if the end of the with statement is
             reached without matching any log entries.

class tornado.testing.LogTrapTestCase(methodName='runTest')[源代码]¶

    A test case that captures and discards all logging output if the test passes.

    Some libraries can produce a lot of logging output even when the test succeeds, so this
    class can be useful to minimize the noise. Simply use it as a base class for your test case.
    It is safe to combine with AsyncTestCase via multiple inheritance (class MyTestCase
    (AsyncHTTPTestCase, LogTrapTestCase):)

    This class assumes that only one log handler is configured and that it is a StreamHandler.
    This is true for both logging.basicConfig and the “pretty logging” configured by
    tornado.options. It is not compatible with other log buffering mechanisms, such as those
    provided by some test runners.

    4.1 版后已移除: Use the unittest module’s --buffer option instead, or ExpectLog.

    Create an instance of the class that will use the named test method when executed. Raises a
    ValueError if the instance does not have a method with the specified name.

Test runner¶

tornado.testing.main(**kwargs)[源代码]¶

    A simple test runner.

    This test runner is essentially equivalent to unittest.main from the standard library, but
    adds support for tornado-style option parsing and log formatting.

    The easiest way to run a test is via the command line:

    python -m tornado.testing tornado.test.stack_context_test

    See the standard library unittest module for ways in which tests can be specified.

    Projects with many tests may wish to define a test script like tornado/test/runtests.py.
    This script should define a method all() which returns a test suite and then call
    tornado.testing.main(). Note that even when a test script is used, the all() test suite may
    be overridden by naming a single test on the command line:

    # Runs all tests
    python -m tornado.test.runtests
    # Runs one test
    python -m tornado.test.runtests tornado.test.stack_context_test

    Additional keyword arguments passed through to unittest.main(). For example, use 
    tornado.testing.main(verbosity=2) to show many test details as they are run. See http://
    docs.python.org/library/unittest.html#unittest.main for full argument list.

Helper functions¶

tornado.testing.bind_unused_port(reuse_port=False)[源代码]¶

    Binds a server socket to an available port on localhost.

    Returns a tuple (socket, port).

tornado.testing.get_unused_port()[源代码]¶

    Returns a (hopefully) unused port number.

    This function does not guarantee that the port it returns is available, only that a series
    of get_unused_port calls in a single process return distinct ports.

    Use 版后已移除: bind_unused_port instead, which is guaranteed to find an unused port.

tornado.testing.get_async_test_timeout()[源代码]¶

    Get the global timeout setting for async tests.

    Returns a float, the timeout in seconds.

    3.1 新版功能.

tornado.util — General-purpose utilities¶

Miscellaneous utility functions and classes.

This module is used internally by Tornado. It is not necessarily expected that the functions and
classes defined here will be useful to other applications, but they are documented here in case
they are.

The one public-facing part of this module is the Configurable class and its configure method,
which becomes a part of the interface of its subclasses, including AsyncHTTPClient, IOLoop, and
Resolver.

class tornado.util.ObjectDict[源代码]¶

    Makes a dictionary behave like an object, with attribute-style access.

class tornado.util.GzipDecompressor[源代码]¶

    Streaming gzip decompressor.

    The interface is like that of zlib.decompressobj (without some of the optional arguments,
    but it understands gzip headers and checksums.

    decompress(value, max_length=None)[源代码]¶

        Decompress a chunk, returning newly-available data.

        Some data may be buffered for later processing; flush must be called when there is no
        more input data to ensure that all data was processed.

        If max_length is given, some input data may be left over in unconsumed_tail; you must
        retrieve this value and pass it back to a future call to decompress if it is not empty.

    unconsumed_tail¶

        Returns the unconsumed portion left over

    flush()[源代码]¶

        Return any remaining buffered data not yet returned by decompress.

        Also checks for errors such as truncated input. No other methods may be called on this
        object after flush.

tornado.util.import_object(name)[源代码]¶

    Imports an object by name.

    import_object(‘x’) is equivalent to ‘import x’. import_object(‘x.y.z’) is equivalent to
    ‘from x.y import z’.

    >>> import tornado.escape
    >>> import_object('tornado.escape') is tornado.escape
    True
    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8
    True
    >>> import_object('tornado') is tornado
    True
    >>> import_object('tornado.missing_module')
    Traceback (most recent call last):
        ...
    ImportError: No module named missing_module

tornado.util.errno_from_exception(e)[源代码]¶

    Provides the errno from an Exception object.

    There are cases that the errno attribute was not set so we pull the errno out of the args
    but if someone instantiates an Exception without any args you will get a tuple error. So
    this function abstracts all that behavior to give you a safe way to get the errno.

class tornado.util.Configurable[源代码]¶

    Base class for configurable interfaces.

    A configurable interface is an (abstract) class whose constructor acts as a factory function
    for one of its implementation subclasses. The implementation subclass as well as optional
    keyword arguments to its initializer can be set globally at runtime with configure.

    By using the constructor as the factory method, the interface looks like a normal class,
    isinstance works as usual, etc. This pattern is most useful when the choice of
    implementation is likely to be a global decision (e.g. when epoll is available, always use
    it instead of select), or when a previously-monolithic class has been split into specialized
    subclasses.

    Configurable subclasses must define the class methods configurable_base and
    configurable_default, and use the instance method initialize instead of __init__.

    classmethod configurable_base()[源代码]¶

        Returns the base class of a configurable hierarchy.

        This will normally return the class in which it is defined. (which is not necessarily
        the same as the cls classmethod parameter).

    classmethod configurable_default()[源代码]¶

        Returns the implementation class to be used if none is configured.

    initialize()[源代码]¶

        Initialize a Configurable subclass instance.

        Configurable classes should use initialize instead of __init__.

        在 4.2 版更改: Now accepts positional arguments in addition to keyword arguments.

    classmethod configure(impl, **kwargs)[源代码]¶

        Sets the class to use when the base class is instantiated.

        Keyword arguments will be saved and added to the arguments passed to the constructor.
        This can be used to set global defaults for some parameters.

    classmethod configured_class()[源代码]¶

        Returns the currently configured class.

class tornado.util.ArgReplacer(func, name)[源代码]¶

    Replaces one value in an args, kwargs pair.

    Inspects the function signature to find an argument by name whether it is passed by position
    or keyword. For use in decorators and similar wrappers.

    get_old_value(args, kwargs, default=None)[源代码]¶

        Returns the old value of the named argument without replacing it.

        Returns default if the argument is not present.

    replace(new_value, args, kwargs)[源代码]¶

        Replace the named argument in args, kwargs with new_value.

        Returns (old_value, args, kwargs). The returned args and kwargs objects may not be the
        same as the input objects, or the input objects may be mutated.

        If the named argument was not found, new_value will be added to kwargs and None will be
        returned as old_value.

tornado.util.timedelta_to_seconds(td)[源代码]¶

    Equivalent to td.total_seconds() (introduced in python 2.7).

常见问题¶

  • Why isn’t this example with time.sleep() running in parallel?
  • My code is asynchronous, but it’s not running in parallel in two browser tabs.

Why isn’t this example with time.sleep() running in parallel?¶

Many people’s first foray into Tornado’s concurrency looks something like this:

class BadExampleHandler(RequestHandler):
    def get(self):
        for i in range(5):
            print(i)
            time.sleep(1)

Fetch this handler twice at the same time and you’ll see that the second five-second countdown
doesn’t start until the first one has completely finished. The reason for this is that
time.sleep is a blocking function: it doesn’t allow control to return to the IOLoop so that
other handlers can be run.

Of course, time.sleep is really just a placeholder in these examples, the point is to show what
happens when something in a handler gets slow. No matter what the real code is doing, to achieve
concurrency blocking code must be replaced with non-blocking equivalents. This means one of
three things:

 1. Find a coroutine-friendly equivalent. For time.sleep, use tornado.gen.sleep instead:

    class CoroutineSleepHandler(RequestHandler):
        @gen.coroutine
        def get(self):
            for i in range(5):
                print(i)
                yield gen.sleep(1)

    When this option is available, it is usually the best approach. See the Tornado wiki for
    links to asynchronous libraries that may be useful.

 2. Find a callback-based equivalent. Similar to the first option, callback-based libraries are
    available for many tasks, although they are slightly more complicated to use than a library
    designed for coroutines. These are typically used with tornado.gen.Task as an adapter:

    class CoroutineTimeoutHandler(RequestHandler):
        @gen.coroutine
        def get(self):
            io_loop = IOLoop.current()
            for i in range(5):
                print(i)
                yield gen.Task(io_loop.add_timeout, io_loop.time() + 1)

    Again, the Tornado wiki can be useful to find suitable libraries.

 3. Run the blocking code on another thread. When asynchronous libraries are not available,
    concurrent.futures.ThreadPoolExecutor can be used to run any blocking code on another
    thread. This is a universal solution that can be used for any blocking function whether an
    asynchronous counterpart exists or not:

    executor = concurrent.futures.ThreadPoolExecutor(8)

    class ThreadPoolHandler(RequestHandler):
        @gen.coroutine
        def get(self):
            for i in range(5):
                print(i)
                yield executor.submit(time.sleep, 1)

See the Asynchronous I/O chapter of the Tornado user’s guide for more on blocking and
asynchronous functions.

My code is asynchronous, but it’s not running in parallel in two browser tabs.¶

Even when a handler is asynchronous and non-blocking, it can be surprisingly tricky to verify
this. Browsers will recognize that you are trying to load the same page in two different tabs
and delay the second request until the first has finished. To work around this and see that the
server is in fact working in parallel, do one of two things:

  • Add something to your urls to make them unique. Instead of http://localhost:8888 in both
    tabs, load http://localhost:8888/?x=1 in one and http://localhost:8888/?x=2 in the other.
  • Use two different browsers. For example, Firefox will be able to load a url even while that
    same url is being loaded in a Chrome tab.

版本记录¶

What’s new in Tornado 4.3¶

Nov 6, 2015¶

Highlights¶

  • The new async/await keywords in Python 3.5 are supported. In most cases, async def can be
    used in place of the @gen.coroutine decorator. Inside a function defined with async def, use
    await instead of yield to wait on an asynchronous operation. Coroutines defined with async/
    await will be faster than those defined with @gen.coroutine and yield, but do not support
    some features including Callback/Wait or the ability to yield a Twisted Deferred. See the
    users’ guide for more.
  • The async/await keywords are also available when compiling with Cython in older versions of
    Python.

Deprecation notice¶

  • This will be the last release of Tornado to support Python 2.6 or 3.2. Note that PyPy3 will
    continue to be supported even though it implements a mix of Python 3.2 and 3.3 features.

Installation¶

  • Tornado has several new dependencies: ordereddict on Python 2.6, singledispatch on all
    Python versions prior to 3.4 (This was an optional dependency in prior versions of Tornado,
    and is now mandatory), and backports_abc>=0.4 on all versions prior to 3.5. These
    dependencies will be installed automatically when installing with pip or setup.py install.
    These dependencies will not be required when running on Google App Engine.
  • Binary wheels are provided for Python 3.5 on Windows (32 and 64 bit).

tornado.auth¶

  • New method OAuth2Mixin.oauth2_request can be used to make authenticated requests with an
    access token.
  • Now compatible with callbacks that have been compiled with Cython.

tornado.autoreload¶

  • Fixed an issue with the autoreload command-line wrapper in which imports would be
    incorrectly interpreted as relative.

tornado.curl_httpclient¶

  • Fixed parsing of multi-line headers.
  • allow_nonstandard_methods=True now bypasses body sanity checks, in the same way as in 
    simple_httpclient.
  • The PATCH method now allows a body without allow_nonstandard_methods=True.

tornado.gen¶

  • WaitIterator now supports the async for statement on Python 3.5.
  • @gen.coroutine can be applied to functions compiled with Cython. On python versions prior to
    3.5, the backports_abc package must be installed for this functionality.
  • Multi and multi_future are deprecated and replaced by a unified function multi.

tornado.httpclient¶

  • tornado.httpclient.HTTPError is now copyable with the copy module.

tornado.httpserver¶

  • Requests containing both Content-Length and Transfer-Encoding will be treated as an error.

tornado.httputil¶

  • HTTPHeaders can now be pickled and unpickled.

tornado.ioloop¶

  • IOLoop(make_current=True) now works as intended instead of raising an exception.
  • The Twisted and asyncio IOLoop implementations now clear current() when they exit, like the
    standard IOLoops.
  • IOLoop.add_callback is faster in the single-threaded case.
  • IOLoop.add_callback no longer raises an error when called on a closed IOLoop, but the
    callback will not be invoked.

tornado.iostream¶

  • Coroutine-style usage of IOStream now converts most errors into StreamClosedError, which has
    the effect of reducing log noise from exceptions that are outside the application’s control
    (especially SSL errors).
  • StreamClosedError now has a real_error attribute which indicates why the stream was closed.
    It is the same as the error attribute of IOStream but may be more easily accessible than the
    IOStream itself.
  • Improved error handling in read_until_close.
  • Logging is less noisy when an SSL server is port scanned.
  • EINTR is now handled on all reads.

tornado.locale¶

  • tornado.locale.load_translations now accepts encodings other than UTF-8. UTF-16 and UTF-8
    will be detected automatically if a BOM is present; for other encodings load_translations
    has an encoding parameter.

tornado.locks¶

  • Lock and Semaphore now support the async with statement on Python 3.5.

tornado.log¶

  • A new time-based log rotation mode is available with --log_rotate_mode=time, 
    --log-rotate-when, and log-rotate-interval.

tornado.netutil¶

  • bind_sockets now supports SO_REUSEPORT with the reuse_port=True argument.

tornado.options¶

  • Dashes and underscores are now fully interchangeable in option names.

tornado.queues¶

  • Queue now supports the async for statement on Python 3.5.

tornado.simple_httpclient¶

  • When following redirects, streaming_callback and header_callback will no longer be run on
    the redirect responses (only the final non-redirect).
  • Responses containing both Content-Length and Transfer-Encoding will be treated as an error.

tornado.template¶

  • tornado.template.ParseError now includes the filename in addition to line number.
  • Whitespace handling has become more configurable. The Loader constructor now has a 
    whitespace argument, there is a new template_whitespace Application setting, and there is a
    new {% whitespace %} template directive. All of these options take a mode name defined in
    the tornado.template.filter_whitespace function. The default mode is single, which is the
    same behavior as prior versions of Tornado.
  • Non-ASCII filenames are now supported.

tornado.testing¶

  • ExpectLog objects now have a boolean logged_stack attribute to make it easier to test
    whether an exception stack trace was logged.

tornado.web¶

  • The hard limit of 4000 bytes per outgoing header has been removed.
  • StaticFileHandler returns the correct Content-Type for files with .gz, .bz2, and .xz
    extensions.
  • Responses smaller than 1000 bytes will no longer be compressed.
  • The default gzip compression level is now 6 (was 9).
  • Fixed a regression in Tornado 4.2.1 that broke StaticFileHandler with a path of /.
  • tornado.web.HTTPError is now copyable with the copy module.
  • The exception Finish now accepts an argument which will be passed to the method
    RequestHandler.finish.
  • New Application setting xsrf_cookie_kwargs can be used to set additional attributes such as 
    secure or httponly on the XSRF cookie.
  • Application.listen now returns the HTTPServer it created.

tornado.websocket¶

  • Fixed handling of continuation frames when compression is enabled.

What’s new in Tornado 4.2.1¶

Jul 17, 2015¶

Security fix¶

  • This release fixes a path traversal vulnerability in StaticFileHandler, in which files whose
    names started with the static_path directory but were not actually in that directory could
    be accessed.

What’s new in Tornado 4.2¶

May 26, 2015¶

Backwards-compatibility notes¶

  • SSLIOStream.connect and IOStream.start_tls now validate certificates by default.
  • Certificate validation will now use the system CA root certificates instead of certifi when
    possible (i.e. Python 2.7.9+ or 3.4+). This includes IOStream and simple_httpclient, but not
    curl_httpclient.
  • The default SSL configuration has become stricter, using ssl.create_default_context where
    available on the client side. (On the server side, applications are encouraged to migrate
    from the ssl_options dict-based API to pass an ssl.SSLContext instead).
  • The deprecated classes in the tornado.auth module, GoogleMixin, FacebookMixin, and 
    FriendFeedMixin have been removed.

New modules: tornado.locks and tornado.queues¶

These modules provide classes for coordinating coroutines, merged from Toro.

To port your code from Toro’s queues to Tornado 4.2, import Queue, PriorityQueue, or LifoQueue
from tornado.queues instead of from toro.

Use Queue instead of Toro’s JoinableQueue. In Tornado the methods join and task_done are
available on all queues, not on a special JoinableQueue.

Tornado queues raise exceptions specific to Tornado instead of reusing exceptions from the
Python standard library. Therefore instead of catching the standard queue.Empty exception from
Queue.get_nowait, catch the special tornado.queues.QueueEmpty exception, and instead of catching
the standard queue.Full from Queue.get_nowait, catch tornado.queues.QueueFull.

To port from Toro’s locks to Tornado 4.2, import Condition, Event, Semaphore, BoundedSemaphore,
or Lock from tornado.locks instead of from toro.

Toro’s Semaphore.wait allowed a coroutine to wait for the semaphore to be unlocked without
acquiring it. This encouraged unorthodox patterns; in Tornado, just use acquire.

Toro’s Event.wait raised a Timeout exception after a timeout. In Tornado, Event.wait raises
tornado.gen.TimeoutError.

Toro’s Condition.wait also raised Timeout, but in Tornado, the Future returned by Condition.wait
resolves to False after a timeout:

@gen.coroutine
def await_notification():
    if not (yield condition.wait(timeout=timedelta(seconds=1))):
        print('timed out')
    else:
        print('condition is true')

In lock and queue methods, wherever Toro accepted deadline as a keyword argument, Tornado names
the argument timeout instead.

Toro’s AsyncResult is not merged into Tornado, nor its exceptions NotReady and AlreadySet. Use a
Future instead. If you wrote code like this:

from tornado import gen
import toro

result = toro.AsyncResult()

@gen.coroutine
def setter():
    result.set(1)

@gen.coroutine
def getter():
    value = yield result.get()
    print(value)  # Prints "1".

Then the Tornado equivalent is:

from tornado import gen
from tornado.concurrent import Future

result = Future()

@gen.coroutine
def setter():
    result.set_result(1)

@gen.coroutine
def getter():
    value = yield result
    print(value)  # Prints "1".

tornado.autoreload¶

  • Improved compatibility with Windows.
  • Fixed a bug in Python 3 if a module was imported during a reload check.

tornado.concurrent¶

  • run_on_executor now accepts arguments to control which attributes it uses to find the IOLoop
    and executor.

tornado.curl_httpclient¶

  • Fixed a bug that would cause the client to stop processing requests if an exception occurred
    in certain places while there is a queue.

tornado.escape¶

  • xhtml_escape now supports numeric character references in hex format (&#x20;)

tornado.gen¶

  • WaitIterator no longer uses weak references, which fixes several garbage-collection-related
    bugs.
  • tornado.gen.Multi and tornado.gen.multi_future (which are used when yielding a list or dict
    in a coroutine) now log any exceptions after the first if more than one Future fails
    (previously they would be logged when the Future was garbage-collected, but this is more
    reliable). Both have a new keyword argument quiet_exceptions to suppress logging of certain
    exception types; to use this argument you must call Multi or multi_future directly instead
    of simply yielding a list.
  • multi_future now works when given multiple copies of the same Future.
  • On Python 3, catching an exception in a coroutine no longer leads to leaks via 
    Exception.__context__.

tornado.httpclient¶

  • The raise_error argument now works correctly with the synchronous HTTPClient.
  • The synchronous HTTPClient no longer interferes with IOLoop.current().

tornado.httpserver¶

  • HTTPServer is now a subclass of tornado.util.Configurable.

tornado.httputil¶

  • HTTPHeaders can now be copied with copy.copy and copy.deepcopy.

tornado.ioloop¶

  • The IOLoop constructor now has a make_current keyword argument to control whether the new
    IOLoop becomes IOLoop.current().
  • Third-party implementations of IOLoop should accept **kwargs in their initialize methods and
    pass them to the superclass implementation.
  • PeriodicCallback is now more efficient when the clock jumps forward by a large amount.

tornado.iostream¶

  • SSLIOStream.connect and IOStream.start_tls now validate certificates by default.
  • New method SSLIOStream.wait_for_handshake allows server-side applications to wait for the
    handshake to complete in order to verify client certificates or use NPN/ALPN.
  • The Future returned by SSLIOStream.connect now resolves after the handshake is complete
    instead of as soon as the TCP connection is established.
  • Reduced logging of SSL errors.
  • BaseIOStream.read_until_close now works correctly when a streaming_callback is given but 
    callback is None (i.e. when it returns a Future)

tornado.locale¶

  • New method GettextLocale.pgettext allows additional context to be supplied for gettext
    translations.

tornado.log¶

  • define_logging_options now works correctly when given a non-default options object.

tornado.process¶

  • New method Subprocess.wait_for_exit is a coroutine-friendly version of
    Subprocess.set_exit_callback.

tornado.simple_httpclient¶

  • Improved performance on Python 3 by reusing a single ssl.SSLContext.
  • New constructor argument max_body_size controls the maximum response size the client is
    willing to accept. It may be bigger than max_buffer_size if streaming_callback is used.

tornado.tcpserver¶

  • TCPServer.handle_stream may be a coroutine (so that any exceptions it raises will be
    logged).

tornado.util¶

  • import_object now supports unicode strings on Python 2.
  • Configurable.initialize now supports positional arguments.

tornado.web¶

  • Key versioning support for cookie signing. cookie_secret application setting can now contain
    a dict of valid keys with version as key. The current signing key then must be specified via
    key_version setting.
  • Parsing of the If-None-Match header now follows the RFC and supports weak validators.
  • Passing secure=False or httponly=False to RequestHandler.set_cookie now works as expected
    (previously only the presence of the argument was considered and its value was ignored).
  • RequestHandler.get_arguments now requires that its strip argument be of type bool. This
    helps prevent errors caused by the slightly dissimilar interfaces between the singular and
    plural methods.
  • Errors raised in _handle_request_exception are now logged more reliably.
  • RequestHandler.redirect now works correctly when called from a handler whose path begins
    with two slashes.
  • Passing messages containing % characters to tornado.web.HTTPError no longer causes broken
    error messages.

tornado.websocket¶

  • The on_close method will no longer be called more than once.
  • When the other side closes a connection, we now echo the received close code back instead of
    sending an empty close frame.

What’s new in Tornado 4.1¶

Feb 7, 2015¶

Highlights¶

  • If a Future contains an exception but that exception is never examined or re-raised (e.g. by
    yielding the Future), a stack trace will be logged when the Future is garbage-collected.
  • New class tornado.gen.WaitIterator provides a way to iterate over Futures in the order they
    resolve.
  • The tornado.websocket module now supports compression via the “permessage-deflate”
    extension. Override WebSocketHandler.get_compression_options to enable on the server side,
    and use the compression_options keyword argument to websocket_connect on the client side.
  • When the appropriate packages are installed, it is possible to yield asyncio.Future or
    Twisted Defered objects in Tornado coroutines.

Backwards-compatibility notes¶

  • HTTPServer now calls start_request with the correct arguments. This change is
    backwards-incompatible, afffecting any application which implemented
    HTTPServerConnectionDelegate by following the example of Application instead of the
    documented method signatures.

tornado.concurrent¶

  • If a Future contains an exception but that exception is never examined or re-raised (e.g. by
    yielding the Future), a stack trace will be logged when the Future is garbage-collected.
  • Future now catches and logs exceptions in its callbacks.

tornado.curl_httpclient¶

  • tornado.curl_httpclient now supports request bodies for PATCH and custom methods.
  • tornado.curl_httpclient now supports resubmitting bodies after following redirects for
    methods other than POST.
  • curl_httpclient now runs the streaming and header callbacks on the IOLoop.
  • tornado.curl_httpclient now uses its own logger for debug output so it can be filtered more
    easily.

tornado.gen¶

  • New class tornado.gen.WaitIterator provides a way to iterate over Futures in the order they
    resolve.
  • When the singledispatch library is available (standard on Python 3.4, available via pip 
    install singledispatch on older versions), the convert_yielded function can be used to make
    other kinds of objects yieldable in coroutines.
  • New function tornado.gen.sleep is a coroutine-friendly analogue to time.sleep.
  • gen.engine now correctly captures the stack context for its callbacks.

tornado.httpclient¶

  • tornado.httpclient.HTTPRequest accepts a new argument raise_error=False to suppress the
    default behavior of raising an error for non-200 response codes.

tornado.httpserver¶

  • HTTPServer now calls start_request with the correct arguments. This change is
    backwards-incompatible, afffecting any application which implemented
    HTTPServerConnectionDelegate by following the example of Application instead of the
    documented method signatures.
  • HTTPServer now tolerates extra newlines which are sometimes inserted between requests on
    keep-alive connections.
  • HTTPServer can now use keep-alive connections after a request with a chunked body.
  • HTTPServer now always reports HTTP/1.1 instead of echoing the request version.

tornado.httputil¶

  • New function tornado.httputil.split_host_and_port for parsing the netloc portion of URLs.
  • The context argument to HTTPServerRequest is now optional, and if a context is supplied the 
    remote_ip attribute is also optional.
  • HTTPServerRequest.body is now always a byte string (previously the default empty body would
    be a unicode string on python 3).
  • Header parsing now works correctly when newline-like unicode characters are present.
  • Header parsing again supports both CRLF and bare LF line separators.
  • Malformed multipart/form-data bodies will always be logged quietly instead of raising an
    unhandled exception; previously the behavior was inconsistent depending on the exact error.

tornado.ioloop¶

  • The kqueue and select IOLoop implementations now report writeability correctly, fixing flow
    control in IOStream.
  • When a new IOLoop is created, it automatically becomes “current” for the thread if there is
    not already a current instance.
  • New method PeriodicCallback.is_running can be used to see whether the PeriodicCallback has
    been started.

tornado.iostream¶

  • IOStream.start_tls now uses the server_hostname parameter for certificate validation.
  • SSLIOStream will no longer consume 100% CPU after certain error conditions.
  • SSLIOStream no longer logs EBADF errors during the handshake as they can result from nmap
    scans in certain modes.

tornado.options¶

  • parse_config_file now always decodes the config file as utf8 on Python 3.
  • tornado.options.define more accurately finds the module defining the option.

tornado.platform.asyncio¶

  • It is now possible to yield asyncio.Future objects in coroutines when the singledispatch
    library is available and tornado.platform.asyncio has been imported.
  • New methods tornado.platform.asyncio.to_tornado_future and to_asyncio_future convert between
    the two libraries’ Future classes.

tornado.platform.twisted¶

  • It is now possible to yield Deferred objects in coroutines when the singledispatch library
    is available and tornado.platform.twisted has been imported.

tornado.tcpclient¶

  • TCPClient will no longer raise an exception due to an ill-timed timeout.

tornado.tcpserver¶

  • TCPServer no longer ignores its read_chunk_size argument.

tornado.testing¶

  • AsyncTestCase has better support for multiple exceptions. Previously it would silently
    swallow all but the last; now it raises the first and logs all the rest.
  • AsyncTestCase now cleans up Subprocess state on tearDown when necessary.

tornado.web¶

  • The asynchronous decorator now understands concurrent.futures.Future in addition to
    tornado.concurrent.Future.
  • StaticFileHandler no longer logs a stack trace if the connection is closed while sending the
    file.
  • RequestHandler.send_error now supports a reason keyword argument, similar to
    tornado.web.HTTPError.
  • RequestHandler.locale now has a property setter.
  • Application.add_handlers hostname matching now works correctly with IPv6 literals.
  • Redirects for the Application default_host setting now match the request protocol instead of
    redirecting HTTPS to HTTP.
  • Malformed _xsrf cookies are now ignored instead of causing uncaught exceptions.
  • Application.start_request now has the same signature as
    HTTPServerConnectionDelegate.start_request.

tornado.websocket¶

  • The tornado.websocket module now supports compression via the “permessage-deflate”
    extension. Override WebSocketHandler.get_compression_options to enable on the server side,
    and use the compression_options keyword argument to websocket_connect on the client side.
  • WebSocketHandler no longer logs stack traces when the connection is closed.
  • WebSocketHandler.open now accepts *args, **kw for consistency with RequestHandler.get and
    related methods.
  • The Sec-WebSocket-Version header now includes all supported versions.
  • websocket_connect now has a on_message_callback keyword argument for callback-style use
    without read_message().

What’s new in Tornado 4.0.2¶

Sept 10, 2014¶

Bug fixes¶

  • Fixed a bug that could sometimes cause a timeout to fire after being cancelled.
  • AsyncTestCase once again passes along arguments to test methods, making it compatible with
    extensions such as Nose’s test generators.
  • StaticFileHandler can again compress its responses when gzip is enabled.
  • simple_httpclient passes its max_buffer_size argument to the underlying stream.
  • Fixed a reference cycle that can lead to increased memory consumption.
  • add_accept_handler will now limit the number of times it will call accept per IOLoop
    iteration, addressing a potential starvation issue.
  • Improved error handling in IOStream.connect (primarily for FreeBSD systems)

What’s new in Tornado 4.0.1¶

Aug 12, 2014¶

  • The build will now fall back to pure-python mode if the C extension fails to build for any
    reason (previously it would fall back for some errors but not others).
  • IOLoop.call_at and IOLoop.call_later now always return a timeout handle for use with
    IOLoop.remove_timeout.
  • If any callback of a PeriodicCallback or IOStream returns a Future, any error raised in that
    future will now be logged (similar to the behavior of IOLoop.add_callback).
  • Fixed an exception in client-side websocket connections when the connection is closed.
  • simple_httpclient once again correctly handles 204 status codes with no content-length
    header.
  • Fixed a regression in simple_httpclient that would result in timeouts for certain kinds of
    errors.

What’s new in Tornado 4.0¶

July 15, 2014¶

Highlights¶

  • The tornado.web.stream_request_body decorator allows large files to be uploaded with limited
    memory usage.
  • Coroutines are now faster and are used extensively throughout Tornado itself. More methods
    now return Futures, including most IOStream methods and RequestHandler.flush.
  • Many user-overridden methods are now allowed to return a Future for flow control.
  • HTTP-related code is now shared between the tornado.httpserver, tornado.simple_httpclient
    and tornado.wsgi modules, making support for features such as chunked and gzip encoding more
    consistent. HTTPServer now uses new delegate interfaces defined in tornado.httputil in
    addition to its old single-callback interface.
  • New module tornado.tcpclient creates TCP connections with non-blocking DNS, SSL handshaking,
    and support for IPv6.

Backwards-compatibility notes¶

  • tornado.concurrent.Future is no longer thread-safe; use concurrent.futures.Future when
    thread-safety is needed.
  • Tornado now depends on the certifi package instead of bundling its own copy of the Mozilla
    CA list. This will be installed automatically when using pip or easy_install.
  • This version includes the changes to the secure cookie format first introduced in version
    3.2.1, and the xsrf token change in version 3.2.2. If you are upgrading from an earlier
    version, see those versions’ release notes.
  • WebSocket connections from other origin sites are now rejected by default. To accept
    cross-origin websocket connections, override the new method WebSocketHandler.check_origin.
  • WebSocketHandler no longer supports the old draft 76 protocol (this mainly affects Safari
    5.x browsers). Applications should use non-websocket workarounds for these browsers.
  • Authors of alternative IOLoop implementations should see the changes to IOLoop.add_handler
    in this release.
  • The RequestHandler.async_callback and WebSocketHandler.async_callback wrapper functions have
    been removed; they have been obsolete for a long time due to stack contexts (and more
    recently coroutines).
  • curl_httpclient now requires a minimum of libcurl version 7.21.1 and pycurl 7.18.2.
  • Support for RequestHandler.get_error_html has been removed; override
    RequestHandler.write_error instead.

Other notes¶

  • The git repository has moved to https://github.com/tornadoweb/tornado. All old links should
    be redirected to the new location.
  • An announcement mailing list is now available.
  • All Tornado modules are now importable on Google App Engine (although the App Engine
    environment does not allow the system calls used by IOLoop so many modules are still
    unusable).

tornado.auth¶

  • Fixed a bug in .FacebookMixin on Python 3.
  • When using the Future interface, exceptions are more reliably delivered to the caller.

tornado.concurrent¶

  • tornado.concurrent.Future is now always thread-unsafe (previously it would be thread-safe if
    the concurrent.futures package was available). This improves performance and provides more
    consistent semantics. The parts of Tornado that accept Futures will accept both Tornado’s
    thread-unsafe Futures and the thread-safe concurrent.futures.Future.
  • tornado.concurrent.Future now includes all the functionality of the old TracebackFuture
    class. TracebackFuture is now simply an alias for Future.

tornado.curl_httpclient¶

  • curl_httpclient now passes along the HTTP “reason” string in response.reason.

tornado.gen¶

  • Performance of coroutines has been improved.
  • Coroutines no longer generate StackContexts by default, but they will be created on demand
    when needed.
  • The internals of the tornado.gen module have been rewritten to improve performance when
    using Futures, at the expense of some performance degradation for the older YieldPoint
    interfaces.
  • New function with_timeout wraps a Future and raises an exception if it doesn’t complete in a
    given amount of time.
  • New object moment can be yielded to allow the IOLoop to run for one iteration before
    resuming.
  • Task is now a function returning a Future instead of a YieldPoint subclass. This change
    should be transparent to application code, but allows Task to take advantage of the
    newly-optimized Future handling.

tornado.http1connection¶

  • New module contains the HTTP implementation shared by tornado.httpserver and 
    tornado.simple_httpclient.

tornado.httpclient¶

  • The command-line HTTP client (python -m tornado.httpclient $URL) now works on Python 3.
  • Fixed a memory leak in AsyncHTTPClient shutdown that affected applications that created many
    HTTP clients and IOLoops.
  • New client request parameter decompress_response replaces the existing use_gzip parameter;
    both names are accepted.

tornado.httpserver¶

  • tornado.httpserver.HTTPRequest has moved to tornado.httputil.HTTPServerRequest.
  • HTTP implementation has been unified with tornado.simple_httpclient in
    tornado.http1connection.
  • Now supports Transfer-Encoding: chunked for request bodies.
  • Now supports Content-Encoding: gzip for request bodies if decompress_request=True is passed
    to the HTTPServer constructor.
  • The connection attribute of HTTPServerRequest is now documented for public use; applications
    are expected to write their responses via the HTTPConnection interface.
  • The HTTPServerRequest.write and HTTPServerRequest.finish methods are now deprecated. (
    RequestHandler.write and RequestHandler.finish are not deprecated; this only applies to the
    methods on HTTPServerRequest)
  • HTTPServer now supports HTTPServerConnectionDelegate in addition to the old request_callback
    interface. The delegate interface supports streaming of request bodies.
  • HTTPServer now detects the error of an application sending a Content-Length error that is
    inconsistent with the actual content.
  • New constructor arguments max_header_size and max_body_size allow separate limits to be set
    for different parts of the request. max_body_size is applied even in streaming mode.
  • New constructor argument chunk_size can be used to limit the amount of data read into memory
    at one time per request.
  • New constructor arguments idle_connection_timeout and body_timeout allow time limits to be
    placed on the reading of requests.
  • Form-encoded message bodies are now parsed for all HTTP methods, not just POST, PUT, and 
    PATCH.

tornado.httputil¶

  • HTTPServerRequest was moved to this module from tornado.httpserver.
  • New base classes HTTPConnection, HTTPServerConnectionDelegate, and HTTPMessageDelegate
    define the interaction between applications and the HTTP implementation.

tornado.ioloop¶

  • IOLoop.add_handler and related methods now accept file-like objects in addition to raw file
    descriptors. Passing the objects is recommended (when possible) to avoid a
    garbage-collection-related problem in unit tests.
  • New method IOLoop.clear_instance makes it possible to uninstall the singleton instance.
  • Timeout scheduling is now more robust against slow callbacks.
  • IOLoop.add_timeout is now a bit more efficient.
  • When a function run by the IOLoop returns a Future and that Future has an exception, the
    IOLoop will log the exception.
  • New method IOLoop.spawn_callback simplifies the process of launching a fire-and-forget
    callback that is separated from the caller’s stack context.
  • New methods IOLoop.call_later and IOLoop.call_at simplify the specification of relative or
    absolute timeouts (as opposed to add_timeout, which used the type of its argument).

tornado.iostream¶

  • The callback argument to most IOStream methods is now optional. When called without a
    callback the method will return a Future for use with coroutines.
  • New method IOStream.start_tls converts an IOStream to an SSLIOStream.
  • No longer gets confused when an IOError or OSError without an errno attribute is raised.
  • BaseIOStream.read_bytes now accepts a partial keyword argument, which can be used to return
    before the full amount has been read. This is a more coroutine-friendly alternative to 
    streaming_callback.
  • BaseIOStream.read_until and read_until_regex now acept a max_bytes keyword argument which
    will cause the request to fail if it cannot be satisfied from the given number of bytes.
  • IOStream no longer reads from the socket into memory if it does not need data to satisfy a
    pending read. As a side effect, the close callback will not be run immediately if the other
    side closes the connection while there is unconsumed data in the buffer.
  • The default chunk_size has been increased to 64KB (from 4KB)
  • The IOStream constructor takes a new keyword argument max_write_buffer_size (defaults to
    unlimited). Calls to BaseIOStream.write will raise StreamBufferFullError if the amount of
    unsent buffered data exceeds this limit.
  • ETIMEDOUT errors are no longer logged. If you need to distinguish timeouts from other forms
    of closed connections, examine stream.error from a close callback.

tornado.netutil¶

  • When bind_sockets chooses a port automatically, it will now use the same port for IPv4 and
    IPv6.
  • TLS compression is now disabled by default on Python 3.3 and higher (it is not possible to
    change this option in older versions).

tornado.options¶

  • It is now possible to disable the default logging configuration by setting options.logging
    to None instead of the string "none".

tornado.platform.asyncio¶

  • Now works on Python 2.6.
  • Now works with Trollius version 0.3.

tornado.platform.twisted¶

  • TwistedIOLoop now works on Python 3.3+ (with Twisted 14.0.0+).

tornado.simple_httpclient¶

  • simple_httpclient has better support for IPv6, which is now enabled by default.
  • Improved default cipher suite selection (Python 2.7+).
  • HTTP implementation has been unified with tornado.httpserver in tornado.http1connection
  • Streaming request bodies are now supported via the body_producer keyword argument to
    tornado.httpclient.HTTPRequest.
  • The expect_100_continue keyword argument to tornado.httpclient.HTTPRequest allows the use of
    the HTTP Expect: 100-continue feature.
  • simple_httpclient now raises the original exception (e.g. an IOError) in more cases, instead
    of converting everything to HTTPError.

tornado.stack_context¶

  • The stack context system now has less performance overhead when no stack contexts are
    active.

tornado.tcpclient¶

  • New module which creates TCP connections and IOStreams, including name resolution,
    connecting, and SSL handshakes.

tornado.testing¶

  • AsyncTestCase now attempts to detect test methods that are generators but were not run with 
    @gen_test or any similar decorator (this would previously result in the test silently being
    skipped).
  • Better stack traces are now displayed when a test times out.
  • The @gen_test decorator now passes along *args, **kwargs so it can be used on functions with
    arguments.
  • Fixed the test suite when unittest2 is installed on Python 3.

tornado.web¶

  • It is now possible to support streaming request bodies with the stream_request_body
    decorator and the new RequestHandler.data_received method.
  • RequestHandler.flush now returns a Future if no callback is given.
  • New exception Finish may be raised to finish a request without triggering error handling.
  • When gzip support is enabled, all text/* mime types will be compressed, not just those on a
    whitelist.
  • Application now implements the HTTPMessageDelegate interface.
  • HEAD requests in StaticFileHandler no longer read the entire file.
  • StaticFileHandler now streams response bodies to the client.
  • New setting compress_response replaces the existing gzip setting; both names are accepted.
  • XSRF cookies that were not generated by this module (i.e. strings without any particular
    formatting) are once again accepted (as long as the cookie and body/header match). This
    pattern was common for testing and non-browser clients but was broken by the changes in
    Tornado 3.2.2.

tornado.websocket¶

  • WebSocket connections from other origin sites are now rejected by default. Browsers do not
    use the same-origin policy for WebSocket connections as they do for most other
    browser-initiated communications. This can be surprising and a security risk, so we disallow
    these connections on the server side by default. To accept cross-origin websocket
    connections, override the new method WebSocketHandler.check_origin.
  • WebSocketHandler.close and WebSocketClientConnection.close now support code and reason
    arguments to send a status code and message to the other side of the connection when
    closing. Both classes also have close_code and close_reason attributes to receive these
    values when the other side closes.
  • The C speedup module now builds correctly with MSVC, and can support messages larger than
    2GB on 64-bit systems.
  • The fallback mechanism for detecting a missing C compiler now works correctly on Mac OS X.
  • Arguments to WebSocketHandler.open are now decoded in the same way as arguments to
    RequestHandler.get and similar methods.
  • It is now allowed to override prepare in a WebSocketHandler, and this method may generate
    HTTP responses (error pages) in the usual way. The HTTP response methods are still not
    allowed once the WebSocket handshake has completed.

tornado.wsgi¶

  • New class WSGIAdapter supports running a Tornado Application on a WSGI server in a way that
    is more compatible with Tornado’s non-WSGI HTTPServer. WSGIApplication is deprecated in
    favor of using WSGIAdapter with a regular Application.
  • WSGIAdapter now supports gzipped output.

What’s new in Tornado 3.2.2¶

June 3, 2014¶

Security fixes¶

  • The XSRF token is now encoded with a random mask on each request. This makes it safe to
    include in compressed pages without being vulnerable to the BREACH attack. This applies to
    most applications that use both the xsrf_cookies and gzip options (or have gzip applied by a
    proxy).

Backwards-compatibility notes¶

  • If Tornado 3.2.2 is run at the same time as older versions on the same domain, there is some
    potential for issues with the differing cookie versions. The Application setting 
    xsrf_cookie_version=1 can be used for a transitional period to generate the older cookie
    format on newer servers.

Other changes¶

  • tornado.platform.asyncio is now compatible with trollius version 0.3.

What’s new in Tornado 3.2.1¶

May 5, 2014¶

Security fixes¶

  • The signed-value format used by RequestHandler.set_secure_cookie and
    RequestHandler.get_secure_cookie has changed to be more secure. This is a disruptive change.
    The secure_cookie functions take new version parameters to support transitions between
    cookie formats.
  • The new cookie format fixes a vulnerability that may be present in applications that use
    multiple cookies where the name of one cookie is a prefix of the name of another.
  • To minimize disruption, cookies in the older format will be accepted by default until they
    expire. Applications that may be vulnerable can reject all cookies in the older format by
    passing min_version=2 to RequestHandler.get_secure_cookie.
  • Thanks to Joost Pol of Certified Secure for reporting this issue.

Backwards-compatibility notes¶

  • Signed cookies issued by RequestHandler.set_secure_cookie in Tornado 3.2.1 cannot be read by
    older releases. If you need to run 3.2.1 in parallel with older releases, you can pass 
    version=1 to RequestHandler.set_secure_cookie to issue cookies that are backwards-compatible
    (but have a known weakness, so this option should only be used for a transitional period).

Other changes¶

  • The C extension used to speed up the websocket module now compiles correctly on Windows with
    MSVC and 64-bit mode. The fallback to the pure-Python alternative now works correctly on Mac
    OS X machines with no C compiler installed.

What’s new in Tornado 3.2¶

Jan 14, 2014¶

Installation¶

  • Tornado now depends on the backports.ssl_match_hostname when running on Python 2. This will
    be installed automatically when using pip or easy_install
  • Tornado now includes an optional C extension module, which greatly improves performance of
    websockets. This extension will be built automatically if a C compiler is found at install
    time.

New modules¶

  • The tornado.platform.asyncio module provides integration with the asyncio module introduced
    in Python 3.4 (also available for Python 3.3 with pip install asyncio).

tornado.auth¶

  • Added GoogleOAuth2Mixin support authentication to Google services with OAuth 2 instead of
    OpenID and OAuth 1.
  • FacebookGraphMixin has been updated to use the current Facebook login URL, which saves a
    redirect.

tornado.concurrent¶

  • TracebackFuture now accepts a timeout keyword argument (although it is still incorrect to
    use a non-zero timeout in non-blocking code).

tornado.curl_httpclient¶

  • tornado.curl_httpclient now works on Python 3 with the soon-to-be-released pycurl 7.19.3,
    which will officially support Python 3 for the first time. Note that there are some
    unofficial Python 3 ports of pycurl (Ubuntu has included one for its past several releases);
    these are not supported for use with Tornado.

tornado.escape¶

  • xhtml_escape now escapes apostrophes as well.
  • tornado.escape.utf8, to_unicode, and native_str now raise TypeError instead of
    AssertionError when given an invalid value.

tornado.gen¶

  • Coroutines may now yield dicts in addition to lists to wait for multiple tasks in parallel.
  • Improved performance of tornado.gen when yielding a Future that is already done.

tornado.httpclient¶

  • tornado.httpclient.HTTPRequest now uses property setters so that setting attributes after
    construction applies the same conversions as __init__ (e.g. converting the body attribute to
    bytes).

tornado.httpserver¶

  • Malformed x-www-form-urlencoded request bodies will now log a warning and continue instead
    of causing the request to fail (similar to the existing handling of malformed multipart/
    form-data bodies. This is done mainly because some libraries send this content type by
    default even when the data is not form-encoded.
  • Fix some error messages for unix sockets (and other non-IP sockets)

tornado.ioloop¶

  • IOLoop now uses handle_callback_exception consistently for error logging.
  • IOLoop now frees callback objects earlier, reducing memory usage while idle.
  • IOLoop will no longer call logging.basicConfig if there is a handler defined for the root
    logger or for the tornado or tornado.application loggers (previously it only looked at the
    root logger).

tornado.iostream¶

  • IOStream now recognizes ECONNABORTED error codes in more places (which was mainly an issue
    on Windows).
  • IOStream now frees memory earlier if a connection is closed while there is data in the write
    buffer.
  • PipeIOStream now handles EAGAIN error codes correctly.
  • SSLIOStream now initiates the SSL handshake automatically without waiting for the
    application to try and read or write to the connection.
  • Swallow a spurious exception from set_nodelay when a connection has been reset.

tornado.locale¶

  • Locale.format_date no longer forces the use of absolute dates in Russian.

tornado.log¶

  • Fix an error from tornado.log.enable_pretty_logging when sys.stderr does not have an isatty
    method.
  • tornado.log.LogFormatter now accepts keyword arguments fmt and datefmt.

tornado.netutil¶

  • is_valid_ip (and therefore HTTPRequest.remote_ip) now rejects empty strings.
  • Synchronously using ThreadedResolver at import time to resolve a unicode hostname no longer
    deadlocks.

tornado.platform.twisted¶

  • TwistedResolver now has better error handling.

tornado.process¶

  • Subprocess no longer leaks file descriptors if subprocess.Popen fails.

tornado.simple_httpclient¶

  • simple_httpclient now applies the connect_timeout to requests that are queued and have not
    yet started.
  • On Python 2.6, simple_httpclient now uses TLSv1 instead of SSLv3.
  • simple_httpclient now enforces the connect timeout during DNS resolution.
  • The embedded ca-certificates.crt file has been updated with the current Mozilla CA list.

tornado.web¶

  • StaticFileHandler no longer fails if the client requests a Range that is larger than the
    entire file (Facebook has a crawler that does this).
  • RequestHandler.on_connection_close now works correctly on subsequent requests of a
    keep-alive connection.
  • New application setting default_handler_class can be used to easily set up custom 404 pages.
  • New application settings autoreload, compiled_template_cache, static_hash_cache, and 
    serve_traceback can be used to control individual aspects of debug mode.
  • New methods RequestHandler.get_query_argument and RequestHandler.get_body_argument and new
    attributes HTTPRequest.query_arguments and HTTPRequest.body_arguments allow access to
    arguments without intermingling those from the query string with those from the request
    body.
  • RequestHandler.decode_argument and related methods now raise an HTTPError(400) instead of
    UnicodeDecodeError when the argument could not be decoded.
  • RequestHandler.clear_all_cookies now accepts domain and path arguments, just like
    clear_cookie.
  • It is now possible to specify handlers by name when using the URLSpec class.
  • Application now accepts 4-tuples to specify the name parameter (which previously required
    constructing a URLSpec object instead of a tuple).
  • Fixed an incorrect error message when handler methods return a value other than None or a
    Future.
  • Exceptions will no longer be logged twice when using both @asynchronous and @gen.coroutine

tornado.websocket¶

  • WebSocketHandler.write_message now raises WebSocketClosedError instead of AttributeError
    when the connection has been closed.
  • websocket_connect now accepts preconstructed HTTPRequest objects.
  • Fix a bug with WebSocketHandler when used with some proxies that unconditionally modify the 
    Connection header.
  • websocket_connect now returns an error immediately for refused connections instead of
    waiting for the timeout.
  • WebSocketClientConnection now has a close method.

tornado.wsgi¶

  • WSGIContainer now calls the iterable’s close() method even if an error is raised, in
    compliance with the spec.

What’s new in Tornado 3.1.1¶

Sep 1, 2013¶

  • StaticFileHandler no longer fails if the client requests a Range that is larger than the
    entire file (Facebook has a crawler that does this).
  • RequestHandler.on_connection_close now works correctly on subsequent requests of a
    keep-alive connection.

What’s new in Tornado 3.1¶

Jun 15, 2013¶

Multiple modules¶

  • Many reference cycles have been broken up throughout the package, allowing for more
    efficient garbage collection on CPython.
  • Silenced some log messages when connections are opened and immediately closed (i.e. port
    scans), or other situations related to closed connections.
  • Various small speedups: HTTPHeaders case normalization, UIModule proxy objects, precompile
    some regexes.

tornado.auth¶

  • OAuthMixin always sends oauth_version=1.0 in its request as required by the spec.
  • FacebookGraphMixin now uses self._FACEBOOK_BASE_URL in facebook_request to allow the base
    url to be overridden.
  • The authenticate_redirect and authorize_redirect methods in the tornado.auth mixin classes
    all now return Futures. These methods are asynchronous in OAuthMixin and derived classes,
    although they do not take a callback. The Future these methods return must be yielded if
    they are called from a function decorated with gen.coroutine (but not gen.engine).
  • TwitterMixin now uses /account/verify_credentials to get information about the logged-in
    user, which is more robust against changing screen names.
  • The demos directory (in the source distribution) has a new twitter demo using TwitterMixin.

tornado.escape¶

  • url_escape and url_unescape have a new plus argument (defaulting to True for consistency
    with the previous behavior) which specifies whether they work like urllib.parse.unquote or
    urllib.parse.unquote_plus.

tornado.gen¶

  • Fixed a potential memory leak with long chains of tornado.gen coroutines.

tornado.httpclient¶

  • tornado.httpclient.HTTPRequest takes a new argument auth_mode, which can be either basic or 
    digest. Digest authentication is only supported with tornado.curl_httpclient.
  • tornado.curl_httpclient no longer goes into an infinite loop when pycurl returns a negative
    timeout.
  • curl_httpclient now supports the PATCH and OPTIONS methods without the use of 
    allow_nonstandard_methods=True.
  • Worked around a class of bugs in libcurl that would result in errors from
    IOLoop.update_handler in various scenarios including digest authentication and socks
    proxies.
  • The TCP_NODELAY flag is now set when appropriate in simple_httpclient.
  • simple_httpclient no longer logs exceptions, since those exceptions are made available to
    the caller as HTTPResponse.error.

tornado.httpserver¶

  • tornado.httpserver.HTTPServer handles malformed HTTP headers more gracefully.
  • HTTPServer now supports lists of IPs in X-Forwarded-For (it chooses the last, i.e. nearest
    one).
  • Memory is now reclaimed promptly on CPython when an HTTP request fails because it exceeded
    the maximum upload size.
  • The TCP_NODELAY flag is now set when appropriate in HTTPServer.
  • The HTTPServer no_keep_alive option is now respected with HTTP 1.0 connections that
    explicitly pass Connection: keep-alive.
  • The Connection: keep-alive check for HTTP 1.0 connections is now case-insensitive.
  • The str and repr of tornado.httpserver.HTTPRequest no longer include the request body,
    reducing log spam on errors (and potential exposure/retention of private data).

tornado.httputil¶

  • The cache used in HTTPHeaders will no longer grow without bound.

tornado.ioloop¶

  • Some IOLoop implementations (such as pyzmq) accept objects other than integer file
    descriptors; these objects will now have their .close() method called when the IOLoop` is 
    closed with ``all_fds=True.
  • The stub handles left behind by IOLoop.remove_timeout will now get cleaned up instead of
    waiting to expire.

tornado.iostream¶

  • Fixed a bug in BaseIOStream.read_until_close that would sometimes cause data to be passed to
    the final callback instead of the streaming callback.
  • The IOStream close callback is now run more reliably if there is an exception in 
    _try_inline_read.
  • New method BaseIOStream.set_nodelay can be used to set the TCP_NODELAY flag.
  • Fixed a case where errors in SSLIOStream.connect (and SimpleAsyncHTTPClient) were not being
    reported correctly.

tornado.locale¶

  • Locale.format_date now works on Python 3.

tornado.netutil¶

  • The default Resolver implementation now works on Solaris.
  • Resolver now has a close method.
  • Fixed a potential CPU DoS when tornado.netutil.ssl_match_hostname is used on certificates
    with an abusive wildcard pattern.
  • All instances of ThreadedResolver now share a single thread pool, whose size is set by the
    first one to be created (or the static Resolver.configure method).
  • ExecutorResolver is now documented for public use.
  • bind_sockets now works in configurations with incomplete IPv6 support.

tornado.options¶

  • tornado.options.define with multiple=True now works on Python 3.
  • tornado.options.options and other OptionParser instances support some new dict-like methods:
    items(), iteration over keys, and (read-only) access to options with square braket syntax.
    OptionParser.group_dict returns all options with a given group name, and
    OptionParser.as_dict returns all options.

tornado.process¶

  • tornado.process.Subprocess no longer leaks file descriptors into the child process, which
    fixes a problem in which the child could not detect that the parent process had closed its
    stdin pipe.
  • Subprocess.set_exit_callback now works for subprocesses created without an explicit io_loop
    parameter.

tornado.stack_context¶

  • tornado.stack_context has been rewritten and is now much faster.
  • New function run_with_stack_context facilitates the use of stack contexts with coroutines.

tornado.tcpserver¶

  • The constructors of TCPServer and HTTPServer now take a max_buffer_size keyword argument.

tornado.template¶

  • Some internal names used by the template system have been changed; now all “reserved” names
    in templates start with _tt_.

tornado.testing¶

  • tornado.testing.AsyncTestCase.wait now raises the correct exception when it has been
    modified by tornado.stack_context.
  • tornado.testing.gen_test can now be called as @gen_test(timeout=60) to give some tests a
    longer timeout than others.
  • The environment variable ASYNC_TEST_TIMEOUT can now be set to override the default timeout
    for AsyncTestCase.wait and gen_test.
  • bind_unused_port now passes None instead of 0 as the port to getaddrinfo, which works better
    with some unusual network configurations.

tornado.util¶

  • tornado.util.import_object now works with top-level module names that do not contain a dot.
  • tornado.util.import_object now consistently raises ImportError instead of AttributeError
    when it fails.

tornado.web¶

  • The handlers list passed to the tornado.web.Application constructor and add_handlers methods
    can now contain lists in addition to tuples and URLSpec objects.
  • tornado.web.StaticFileHandler now works on Windows when the client passes an 
    If-Modified-Since timestamp before 1970.
  • New method RequestHandler.log_exception can be overridden to customize the logging behavior
    when an exception is uncaught. Most apps that currently override _handle_request_exception
    can now use a combination of RequestHandler.log_exception and write_error.
  • RequestHandler.get_argument now raises MissingArgumentError (a subclass of
    tornado.web.HTTPError, which is what it raised previously) if the argument cannot be found.
  • Application.reverse_url now uses url_escape with plus=False, i.e. spaces are encoded as %20
    instead of +.
  • Arguments extracted from the url path are now decoded with url_unescape with plus=False, so
    plus signs are left as-is instead of being turned into spaces.
  • RequestHandler.send_error will now only be called once per request, even if multiple
    exceptions are caught by the stack context.
  • The tornado.web.asynchronous decorator is no longer necessary for methods that return a
    Future (i.e. those that use the gen.coroutine or return_future decorators)
  • RequestHandler.prepare may now be asynchronous if it returns a Future. The asynchronous
    decorator is not used with prepare; one of the Future-related decorators should be used
    instead.
  • RequestHandler.current_user may now be assigned to normally.
  • RequestHandler.redirect no longer silently strips control characters and whitespace. It is
    now an error to pass control characters, newlines or tabs.
  • StaticFileHandler has been reorganized internally and now has additional extension points
    that can be overridden in subclasses.
  • StaticFileHandler now supports HTTP Range requests. StaticFileHandler is still not suitable
    for files too large to comfortably fit in memory, but Range support is necessary in some
    browsers to enable seeking of HTML5 audio and video.
  • StaticFileHandler now uses longer hashes by default, and uses the same hashes for Etag as it
    does for versioned urls.
  • StaticFileHandler.make_static_url and RequestHandler.static_url now have an additional
    keyword argument include_version to suppress the url versioning.
  • StaticFileHandler now reads its file in chunks, which will reduce memory fragmentation.
  • Fixed a problem with the Date header and cookie expiration dates when the system locale is
    set to a non-english configuration.

tornado.websocket¶

  • WebSocketHandler now catches StreamClosedError and runs on_close immediately instead of
    logging a stack trace.
  • New method WebSocketHandler.set_nodelay can be used to set the TCP_NODELAY flag.

tornado.wsgi¶

  • Fixed an exception in WSGIContainer when the connection is closed while output is being
    written.

What’s new in Tornado 3.0.2¶

Jun 2, 2013¶

  • tornado.auth.TwitterMixin now defaults to version 1.1 of the Twitter API, instead of version
    1.0 which is being discontinued on June 11. It also now uses HTTPS when talking to Twitter.
  • Fixed a potential memory leak with a long chain of gen.coroutine or gen.engine functions.

What’s new in Tornado 3.0.1¶

Apr 8, 2013¶

  • The interface of tornado.auth.FacebookGraphMixin is now consistent with its documentation
    and the rest of the module. The get_authenticated_user and facebook_request methods return a
    Future and the callback argument is optional.
  • The tornado.testing.gen_test decorator will no longer be recognized as a (broken) test by 
    nose.
  • Work around a bug in Ubuntu 13.04 betas involving an incomplete backport of the
    ssl.match_hostname function.
  • tornado.websocket.websocket_connect now fails cleanly when it attempts to connect to a
    non-websocket url.
  • tornado.testing.LogTrapTestCase once again works with byte strings on Python 2.
  • The request attribute of tornado.httpclient.HTTPResponse is now always an HTTPRequest, never
    a _RequestProxy.
  • Exceptions raised by the tornado.gen module now have better messages when tuples are used as
    callback keys.

What’s new in Tornado 3.0¶

Mar 29, 2013¶

Highlights¶

  • The callback argument to many asynchronous methods is now optional, and these methods return
    a Future. The tornado.gen module now understands Futures, and these methods can be used
    directly without a gen.Task wrapper.
  • New function IOLoop.current returns the IOLoop that is running on the current thread (as
    opposed to IOLoop.instance, which returns a specific thread’s (usually the main thread’s)
    IOLoop.
  • New class tornado.netutil.Resolver provides an asynchronous interface to DNS resolution. The
    default implementation is still blocking, but non-blocking implementations are available
    using one of three optional dependencies: ThreadedResolver using the concurrent.futures
    thread pool, tornado.platform.caresresolver.CaresResolver using the pycares library, or 
    tornado.platform.twisted.TwistedResolver using twisted
  • Tornado’s logging is now less noisy, and it no longer goes directly to the root logger,
    allowing for finer-grained configuration.
  • New class tornado.process.Subprocess wraps subprocess.Popen with PipeIOStream access to the
    child’s file descriptors.
  • IOLoop now has a static configure method like the one on AsyncHTTPClient, which can be used
    to select an IOLoop implementation other than the default.
  • IOLoop can now optionally use a monotonic clock if available (see below for more details).

Backwards-incompatible changes¶

  • Python 2.5 is no longer supported. Python 3 is now supported in a single codebase instead of
    using 2to3
  • The tornado.database module has been removed. It is now available as a separate package,
    torndb
  • Functions that take an io_loop parameter now default to IOLoop.current() instead of
    IOLoop.instance().
  • Empty HTTP request arguments are no longer ignored. This applies to HTTPRequest.arguments
    and RequestHandler.get_argument[s] in WSGI and non-WSGI modes.
  • On Python 3, tornado.escape.json_encode no longer accepts byte strings.
  • On Python 3, the get_authenticated_user methods in tornado.auth now return character strings
    instead of byte strings.
  • tornado.netutil.TCPServer has moved to its own module, tornado.tcpserver.
  • The Tornado test suite now requires unittest2 when run on Python 2.6.
  • tornado.options.options is no longer a subclass of dict; attribute-style access is now
    required.

Detailed changes by module¶

Multiple modules¶

  • Tornado no longer logs to the root logger. Details on the new logging scheme can be found
    under the tornado.log module. Note that in some cases this will require that you add an
    explicit logging configuration in order to see any output (perhaps just calling 
    logging.basicConfig()), although both IOLoop.start() and tornado.options.parse_command_line
    will do this for you.
  • On python 3.2+, methods that take an ssl_options argument (on SSLIOStream, TCPServer, and
    HTTPServer) now accept either a dictionary of options or an ssl.SSLContext object.
  • New optional dependency on concurrent.futures to provide better support for working with
    threads. concurrent.futures is in the standard library for Python 3.2+, and can be installed
    on older versions with pip install futures.

tornado.autoreload¶

  • tornado.autoreload is now more reliable when there are errors at import time.
  • Calling tornado.autoreload.start (or creating an Application with debug=True) twice on the
    same IOLoop now does nothing (instead of creating multiple periodic callbacks). Starting
    autoreload on more than one IOLoop in the same process now logs a warning.
  • Scripts run by autoreload no longer inherit __future__ imports used by Tornado.

tornado.auth¶

  • On Python 3, the get_authenticated_user method family now returns character strings instead
    of byte strings.
  • Asynchronous methods defined in tornado.auth now return a Future, and their callback
    argument is optional. The Future interface is preferred as it offers better error handling
    (the previous interface just logged a warning and returned None).
  • The tornado.auth mixin classes now define a method get_auth_http_client, which can be
    overridden to use a non-default AsyncHTTPClient instance (e.g. to use a different IOLoop)
  • Subclasses of OAuthMixin are encouraged to override OAuthMixin._oauth_get_user_future
    instead of _oauth_get_user, although both methods are still supported.

tornado.concurrent¶

  • New module tornado.concurrent contains code to support working with concurrent.futures, or
    to emulate future-based interface when that module is not available.

tornado.curl_httpclient¶

  • Preliminary support for tornado.curl_httpclient on Python 3. The latest official release of
    pycurl only supports Python 2, but Ubuntu has a port available in 12.10 (apt-get install 
    python3-pycurl). This port currently has bugs that prevent it from handling arbitrary binary
    data but it should work for textual (utf8) resources.
  • Fix a crash with libcurl 7.29.0 if a curl object is created and closed without being used.

tornado.escape¶

  • On Python 3, json_encode no longer accepts byte strings. This mirrors the behavior of the
    underlying json module. Python 2 behavior is unchanged but should be faster.

tornado.gen¶

  • New decorator @gen.coroutine is available as an alternative to @gen.engine. It automatically
    returns a Future, and within the function instead of calling a callback you return a value
    with raise gen.Return(value) (or simply return value in Python 3.3).
  • Generators may now yield Future objects.
  • Callbacks produced by gen.Callback and gen.Task are now automatically stack-context-wrapped,
    to minimize the risk of context leaks when used with asynchronous functions that don’t do
    their own wrapping.
  • Fixed a memory leak involving generators, RequestHandler.flush, and clients closing
    connections while output is being written.
  • Yielding a large list no longer has quadratic performance.

tornado.httpclient¶

  • AsyncHTTPClient.fetch now returns a Future and its callback argument is optional. When the
    future interface is used, any error will be raised automatically, as if HTTPResponse.rethrow
    was called.
  • AsyncHTTPClient.configure and all AsyncHTTPClient constructors now take a defaults keyword
    argument. This argument should be a dictionary, and its values will be used in place of
    corresponding attributes of HTTPRequest that are not set.
  • All unset attributes of tornado.httpclient.HTTPRequest are now None. The default values of
    some attributes (connect_timeout, request_timeout, follow_redirects, max_redirects, use_gzip
    , proxy_password, allow_nonstandard_methods, and validate_cert have been moved from
    HTTPRequest to the client implementations.
  • The max_clients argument to AsyncHTTPClient is now a keyword-only argument.
  • Keyword arguments to AsyncHTTPClient.configure are no longer used when instantiating an
    implementation subclass directly.
  • Secondary AsyncHTTPClient callbacks (streaming_callback, header_callback, and 
    prepare_curl_callback) now respect StackContext.

tornado.httpserver¶

  • HTTPServer no longer logs an error when it is unable to read a second request from an HTTP
    1.1 keep-alive connection.
  • HTTPServer now takes a protocol keyword argument which can be set to https if the server is
    behind an SSL-decoding proxy that does not set any supported X-headers.
  • tornado.httpserver.HTTPConnection now has a set_close_callback method that should be used
    instead of reaching into its stream attribute.
  • Empty HTTP request arguments are no longer ignored. This applies to HTTPRequest.arguments
    and RequestHandler.get_argument[s] in WSGI and non-WSGI modes.

tornado.ioloop¶

  • New function IOLoop.current returns the IOLoop that is running on the current thread (as
    opposed to IOLoop.instance, which returns a specific thread’s (usually the main thread’s)
    IOLoop).
  • New method IOLoop.add_future to run a callback on the IOLoop when an asynchronous Future
    finishes.
  • IOLoop now has a static configure method like the one on AsyncHTTPClient, which can be used
    to select an IOLoop implementation other than the default.
  • The IOLoop poller implementations (select, epoll, kqueue) are now available as distinct
    subclasses of IOLoop. Instantiating IOLoop will continue to automatically choose the best
    available implementation.
  • The IOLoop constructor has a new keyword argument time_func, which can be used to set the
    time function used when scheduling callbacks. This is most useful with the time.monotonic
    function, introduced in Python 3.3 and backported to older versions via the monotime module.
    Using a monotonic clock here avoids problems when the system clock is changed.
  • New function IOLoop.time returns the current time according to the IOLoop. To use the new
    monotonic clock functionality, all calls to IOLoop.add_timeout must be either pass a
    datetime.timedelta or a time relative to IOLoop.time, not time.time. (time.time will
    continue to work only as long as the IOLoop’s time_func argument is not used).
  • New convenience method IOLoop.run_sync can be used to start an IOLoop just long enough to
    run a single coroutine.
  • New method IOLoop.add_callback_from_signal is safe to use in a signal handler (the regular
    add_callback method may deadlock).
  • IOLoop now uses signal.set_wakeup_fd where available (Python 2.6+ on Unix) to avoid a race
    condition that could result in Python signal handlers being delayed.
  • Method IOLoop.running() has been removed.
  • IOLoop has been refactored to better support subclassing.
  • IOLoop.add_callback and add_callback_from_signal now take *args, **kwargs to pass along to
    the callback.

tornado.iostream¶

  • IOStream.connect now has an optional server_hostname argument which will be used for SSL
    certificate validation when applicable. Additionally, when supported (on Python 3.2+), this
    hostname will be sent via SNI (and this is supported by tornado.simple_httpclient)
  • Much of IOStream has been refactored into a separate class BaseIOStream.
  • New class tornado.iostream.PipeIOStream provides the IOStream interface on pipe file
    descriptors.
  • IOStream now raises a new exception tornado.iostream.StreamClosedError when you attempt to
    read or write after the stream has been closed (by either side).
  • IOStream now simply closes the connection when it gets an ECONNRESET error, rather than
    logging it as an error.
  • IOStream.error no longer picks up unrelated exceptions.
  • BaseIOStream.close now has an exc_info argument (similar to the one used in the logging
    module) that can be used to set the stream’s error attribute when closing it.
  • BaseIOStream.read_until_close now works correctly when it is called while there is buffered
    data.
  • Fixed a major performance regression when run on PyPy (introduced in Tornado 2.3).

tornado.log¶

  • New module containing enable_pretty_logging and LogFormatter, moved from the options module.
  • LogFormatter now handles non-ascii data in messages and tracebacks better.

tornado.netutil¶

  • New class tornado.netutil.Resolver provides an asynchronous interface to DNS resolution. The
    default implementation is still blocking, but non-blocking implementations are available
    using one of three optional dependencies: ThreadedResolver using the concurrent.futures
    thread pool, tornado.platform.caresresolver.CaresResolver using the pycares library, or
    tornado.platform.twisted.TwistedResolver using twisted
  • New function tornado.netutil.is_valid_ip returns true if a given string is a valid IP (v4 or
    v6) address.
  • tornado.netutil.bind_sockets has a new flags argument that can be used to pass additional
    flags to getaddrinfo.
  • tornado.netutil.bind_sockets no longer sets AI_ADDRCONFIG; this will cause it to bind to
    both ipv4 and ipv6 more often than before.
  • tornado.netutil.bind_sockets now works when Python was compiled with --disable-ipv6 but IPv6
    DNS resolution is available on the system.
  • tornado.netutil.TCPServer has moved to its own module, tornado.tcpserver.

tornado.options¶

  • The class underlying the functions in tornado.options is now public (
    tornado.options.OptionParser). This can be used to create multiple independent option sets,
    such as for subcommands.
  • tornado.options.parse_config_file now configures logging automatically by default, in the
    same way that parse_command_line does.
  • New function tornado.options.add_parse_callback schedules a callback to be run after the
    command line or config file has been parsed. The keyword argument final=False can be used on
    either parsing function to supress these callbacks.
  • tornado.options.define now takes a callback argument. This callback will be run with the new
    value whenever the option is changed. This is especially useful for options that set other
    options, such as by reading from a config file.
  • tornado.options.parse_command_line --help output now goes to stderr rather than stdout.
  • tornado.options.options is no longer a subclass of dict; attribute-style access is now
    required.
  • tornado.options.options (and OptionParser instances generally) now have a mockable() method
    that returns a wrapper object compatible with mock.patch.
  • Function tornado.options.enable_pretty_logging has been moved to the tornado.log module.

tornado.platform.caresresolver¶

  • New module containing an asynchronous implementation of the Resolver interface, using the 
    pycares library.

tornado.platform.twisted¶

  • New class tornado.platform.twisted.TwistedIOLoop allows Tornado code to be run on the
    Twisted reactor (as opposed to the existing TornadoReactor, which bridges the gap in the
    other direction).
  • New class tornado.platform.twisted.TwistedResolver is an asynchronous implementation of the
    Resolver interface.

tornado.process¶

  • New class tornado.process.Subprocess wraps subprocess.Popen with PipeIOStream access to the
    child’s file descriptors.

tornado.simple_httpclient¶

  • SimpleAsyncHTTPClient now takes a resolver keyword argument (which may be passed to either
    the constructor or configure), to allow it to use the new non-blocking
    tornado.netutil.Resolver.
  • When following redirects, SimpleAsyncHTTPClient now treats a 302 response code the same as a
    303. This is contrary to the HTTP spec but consistent with all browsers and other major HTTP
    clients (including CurlAsyncHTTPClient).
  • The behavior of header_callback with SimpleAsyncHTTPClient has changed and is now the same
    as that of CurlAsyncHTTPClient. The header callback now receives the first line of the
    response (e.g. HTTP/1.0 200 OK) and the final empty line.
  • tornado.simple_httpclient now accepts responses with a 304 status code that include a 
    Content-Length header.
  • Fixed a bug in which SimpleAsyncHTTPClient callbacks were being run in the client’s 
    stack_context.

tornado.stack_context¶

  • stack_context.wrap now runs the wrapped callback in a more consistent environment by
    recreating contexts even if they already exist on the stack.
  • Fixed a bug in which stack contexts could leak from one callback chain to another.
  • Yield statements inside a with statement can cause stack contexts to become inconsistent; an
    exception will now be raised when this case is detected.

tornado.template¶

  • Errors while rendering templates no longer log the generated code, since the enhanced stack
    traces (from version 2.1) should make this unnecessary.
  • The {% apply %} directive now works properly with functions that return both unicode strings
    and byte strings (previously only byte strings were supported).
  • Code in templates is no longer affected by Tornado’s __future__ imports (which previously
    included absolute_import and division).

tornado.testing¶

  • New function tornado.testing.bind_unused_port both chooses a port and binds a socket to it,
    so there is no risk of another process using the same port. get_unused_port is now
    deprecated.
  • New decorator tornado.testing.gen_test can be used to allow for yielding tornado.gen objects
    in tests, as an alternative to the stop and wait methods of AsyncTestCase.
  • tornado.testing.AsyncTestCase and friends now extend unittest2.TestCase when it is available
    (and continue to use the standard unittest module when unittest2 is not available)
  • tornado.testing.ExpectLog can be used as a finer-grained alternative to
    tornado.testing.LogTrapTestCase
  • The command-line interface to tornado.testing.main now supports additional arguments from
    the underlying unittest module: verbose, quiet, failfast, catch, buffer.
  • The deprecated --autoreload option of tornado.testing.main has been removed. Use python -m 
    tornado.autoreload as a prefix command instead.
  • The --httpclient option of tornado.testing.main has been moved to tornado.test.runtests so
    as not to pollute the application option namespace. The tornado.options module’s new
    callback support now makes it easy to add options from a wrapper script instead of putting
    all possible options in tornado.testing.main.
  • AsyncHTTPTestCase no longer calls AsyncHTTPClient.close for tests that use the singleton
    IOLoop.instance.
  • LogTrapTestCase no longer fails when run in unknown logging configurations. This allows
    tests to be run under nose, which does its own log buffering (LogTrapTestCase doesn’t do
    anything useful in this case, but at least it doesn’t break things any more).

tornado.util¶

  • tornado.util.b (which was only intended for internal use) is gone.

tornado.web¶

  • RequestHandler.set_header now overwrites previous header values case-insensitively.
  • tornado.web.RequestHandler has new attributes path_args and path_kwargs, which contain the
    positional and keyword arguments that are passed to the get/post/etc method. These
    attributes are set before those methods are called, so they are available during prepare()
  • tornado.web.ErrorHandler no longer requires XSRF tokens on POST requests, so posts to an
    unknown url will always return 404 instead of complaining about XSRF tokens.
  • Several methods related to HTTP status codes now take a reason keyword argument to specify
    an alternate “reason” string (i.e. the “Not Found” in “HTTP/1.1 404 Not Found”). It is now
    possible to set status codes other than those defined in the spec, as long as a reason
    string is given.
  • The Date HTTP header is now set by default on all responses.
  • Etag/If-None-Match requests now work with StaticFileHandler.
  • StaticFileHandler no longer sets Cache-Control: public unnecessarily.
  • When gzip is enabled in a tornado.web.Application, appropriate Vary: Accept-Encoding headers
    are now sent.
  • It is no longer necessary to pass all handlers for a host in a single
    Application.add_handlers call. Now the request will be matched against the handlers for any 
    host_pattern that includes the request’s Host header.

tornado.websocket¶

  • Client-side WebSocket support is now available: tornado.websocket.websocket_connect
  • WebSocketHandler has new methods ping and on_pong to send pings to the browser (not
    supported on the draft76 protocol)

What’s new in Tornado 2.4.1¶

Nov 24, 2012¶

Bug fixes¶

  • Fixed a memory leak in tornado.stack_context that was especially likely with long-running 
    @gen.engine functions.
  • tornado.auth.TwitterMixin now works on Python 3.
  • Fixed a bug in which IOStream.read_until_close with a streaming callback would sometimes
    pass the last chunk of data to the final callback instead of the streaming callback.

What’s new in Tornado 2.4¶

Sep 4, 2012¶

General¶

  • Fixed Python 3 bugs in tornado.auth, tornado.locale, and tornado.wsgi.

HTTP clients¶

  • Removed max_simultaneous_connections argument from tornado.httpclient (both
    implementations). This argument hasn’t been useful for some time (if you were using it you
    probably want max_clients instead)
  • tornado.simple_httpclient now accepts and ignores HTTP 1xx status responses.

tornado.ioloop and tornado.iostream¶

  • Fixed a bug introduced in 2.3 that would cause IOStream close callbacks to not run if there
    were pending reads.
  • Improved error handling in SSLIOStream and SSL-enabled TCPServer.
  • SSLIOStream.get_ssl_certificate now has a binary_form argument which is passed to 
    SSLSocket.getpeercert.
  • SSLIOStream.write can now be called while the connection is in progress, same as non-SSL
    IOStream (but be careful not to send sensitive data until the connection has completed and
    the certificate has been verified).
  • IOLoop.add_handler cannot be called more than once with the same file descriptor. This was
    always true for epoll, but now the other implementations enforce it too.
  • On Windows, TCPServer uses SO_EXCLUSIVEADDRUSER instead of SO_REUSEADDR.

tornado.template¶

  • {% break %} and {% continue %} can now be used looping constructs in templates.
  • It is no longer an error for an if/else/for/etc block in a template to have an empty body.

tornado.testing¶

  • New class tornado.testing.AsyncHTTPSTestCase is like AsyncHTTPTestCase. but enables SSL for
    the testing server (by default using a self-signed testing certificate).
  • tornado.testing.main now accepts additional keyword arguments and forwards them to
    unittest.main.

tornado.web¶

  • New method RequestHandler.get_template_namespace can be overridden to add additional
    variables without modifying keyword arguments to render_string.
  • RequestHandler.add_header now works with WSGIApplication.
  • RequestHandler.get_secure_cookie now handles a potential error case.
  • RequestHandler.__init__ now calls super().__init__ to ensure that all constructors are
    called when multiple inheritance is used.
  • Docs have been updated with a description of all available Application settings

Other modules¶

  • OAuthMixin now accepts "oob" as a callback_uri.
  • OpenIdMixin now also returns the claimed_id field for the user.
  • tornado.platform.twisted shutdown sequence is now more compatible.
  • The logging configuration used in tornado.options is now more tolerant of non-ascii byte
    strings.

What’s new in Tornado 2.3¶

May 31, 2012¶

HTTP clients¶

  • tornado.httpclient.HTTPClient now supports the same constructor keyword arguments as
    AsyncHTTPClient.
  • The max_clients keyword argument to AsyncHTTPClient.configure now works.
  • tornado.simple_httpclient now supports the OPTIONS and PATCH HTTP methods.
  • tornado.simple_httpclient is better about closing its sockets instead of leaving them for
    garbage collection.
  • tornado.simple_httpclient correctly verifies SSL certificates for URLs containing IPv6
    literals (This bug affected Python 2.5 and 2.6).
  • tornado.simple_httpclient no longer includes basic auth credentials in the Host header when
    those credentials are extracted from the URL.
  • tornado.simple_httpclient no longer modifies the caller-supplied header dictionary, which
    caused problems when following redirects.
  • tornado.curl_httpclient now supports client SSL certificates (using the same client_cert and
    client_key arguments as tornado.simple_httpclient)

HTTP Server¶

  • HTTPServer now works correctly with paths starting with //
  • HTTPHeaders.copy (inherited from dict.copy) now works correctly.
  • HTTPConnection.address is now always the socket address, even for non-IP sockets. 
    HTTPRequest.remote_ip is still always an IP-style address (fake data is used for non-IP
    sockets)
  • Extra data at the end of multipart form bodies is now ignored, which fixes a compatibility
    problem with an iOS HTTP client library.

IOLoop and IOStream¶

  • IOStream now has an error attribute that can be used to determine why a socket was closed.
  • tornado.iostream.IOStream.read_until and read_until_regex are much faster with large input.
  • IOStream.write performs better when given very large strings.
  • IOLoop.instance() is now thread-safe.

tornado.options¶

  • tornado.options options with multiple=True that are set more than once now overwrite rather
    than append. This makes it possible to override values set in parse_config_file with 
    parse_command_line.
  • tornado.options --help output is now prettier.
  • tornado.options.options now supports attribute assignment.

tornado.template¶

  • Template files containing non-ASCII (utf8) characters now work on Python 3 regardless of the
    locale environment variables.
  • Templates now support else clauses in try/except/finally/else blocks.

tornado.web¶

  • tornado.web.RequestHandler now supports the PATCH HTTP method. Note that this means any
    existing methods named patch in RequestHandler subclasses will need to be renamed.
  • tornado.web.addslash and removeslash decorators now send permanent redirects (301) instead
    of temporary (302).
  • RequestHandler.flush now invokes its callback whether there was any data to flush or not.
  • Repeated calls to RequestHandler.set_cookie with the same name now overwrite the previous
    cookie instead of producing additional copies.
  • tornado.web.OutputTransform.transform_first_chunk now takes and returns a status code in
    addition to the headers and chunk. This is a backwards-incompatible change to an interface
    that was never technically private, but was not included in the documentation and does not
    appear to have been used outside Tornado itself.
  • Fixed a bug on python versions before 2.6.5 when URLSpec regexes are constructed from
    unicode strings and keyword arguments are extracted.
  • The reverse_url function in the template namespace now comes from the RequestHandler rather
    than the Application. (Unless overridden, RequestHandler.reverse_url is just an alias for
    the Application method).
  • The Etag header is now returned on 304 responses to an If-None-Match request, improving
    compatibility with some caches.
  • tornado.web will no longer produce responses with status code 304 that also have entity
    headers such as Content-Length.

Other modules¶

  • tornado.auth.FacebookGraphMixin no longer sends post_args redundantly in the url.
  • The extra_params argument to tornado.escape.linkify may now be a callable, to allow
    parameters to be chosen separately for each link.
  • tornado.gen no longer leaks StackContexts when a @gen.engine wrapped function is called
    repeatedly.
  • tornado.locale.get_supported_locales no longer takes a meaningless cls argument.
  • StackContext instances now have a deactivation callback that can be used to prevent further
    propagation.
  • tornado.testing.AsyncTestCase.wait now resets its timeout on each call.
  • tornado.wsgi.WSGIApplication now parses arguments correctly on Python 3.
  • Exception handling on Python 3 has been improved; previously some exceptions such as
    UnicodeDecodeError would generate TypeErrors

What’s new in Tornado 2.2.1¶

Apr 23, 2012¶

Security fixes¶

  • tornado.web.RequestHandler.set_header now properly sanitizes input values to protect against
    header injection, response splitting, etc. (it has always attempted to do this, but the
    check was incorrect). Note that redirects, the most likely source of such bugs, are
    protected by a separate check in RequestHandler.redirect.

Bug fixes¶

  • Colored logging configuration in tornado.options is compatible with Python 3.2.3 (and 3.3).

What’s new in Tornado 2.2¶

Jan 30, 2012¶

Highlights¶

  • Updated and expanded WebSocket support.
  • Improved compatibility in the Twisted/Tornado bridge.
  • Template errors now generate better stack traces.
  • Better exception handling in tornado.gen.

Security fixes¶

  • tornado.simple_httpclient now disables SSLv2 in all cases. Previously SSLv2 would be allowed
    if the Python interpreter was linked against a pre-1.0 version of OpenSSL.

Backwards-incompatible changes¶

  • tornado.process.fork_processes now raises SystemExit if all child processes exit cleanly
    rather than returning None. The old behavior was surprising and inconsistent with most of
    the documented examples of this function (which did not check the return value).
  • On Python 2.6, tornado.simple_httpclient only supports SSLv3. This is because Python 2.6
    does not expose a way to support both SSLv3 and TLSv1 without also supporting the insecure
    SSLv2.
  • tornado.websocket no longer supports the older “draft 76” version of the websocket protocol
    by default, although this version can be enabled by overriding 
    tornado.websocket.WebSocketHandler.allow_draft76.

tornado.httpclient¶

  • SimpleAsyncHTTPClient no longer hangs on HEAD requests, responses with no content, or empty 
    POST/PUT response bodies.
  • SimpleAsyncHTTPClient now supports 303 and 307 redirect codes.
  • tornado.curl_httpclient now accepts non-integer timeouts.
  • tornado.curl_httpclient now supports basic authentication with an empty password.

tornado.httpserver¶

  • HTTPServer with xheaders=True will no longer accept X-Real-IP headers that don’t look like
    valid IP addresses.
  • HTTPServer now treats the Connection request header as case-insensitive.

tornado.ioloop and tornado.iostream¶

  • IOStream.write now works correctly when given an empty string.
  • IOStream.read_until (and read_until_regex) now perform better when there is a lot of
    buffered data, which improves peformance of SimpleAsyncHTTPClient when downloading files
    with lots of chunks.
  • SSLIOStream now works correctly when ssl_version is set to a value other than SSLv23.
  • Idle IOLoops no longer wake up several times a second.
  • tornado.ioloop.PeriodicCallback no longer triggers duplicate callbacks when stopped and
    started repeatedly.

tornado.template¶

  • Exceptions in template code will now show better stack traces that reference lines from the
    original template file.
  • {# and #} can now be used for comments (and unlike the old {% comment %} directive, these
    can wrap other template directives).
  • Template directives may now span multiple lines.

tornado.web¶

  • Now behaves better when given malformed Cookie headers
  • RequestHandler.redirect now has a status argument to send status codes other than 301 and
    302.
  • New method RequestHandler.on_finish may be overridden for post-request processing (as a
    counterpart to RequestHandler.prepare)
  • StaticFileHandler now outputs Content-Length and Etag headers on HEAD requests.
  • StaticFileHandler now has overridable get_version and parse_url_path methods for use in
    subclasses.
  • RequestHandler.static_url now takes an include_host parameter (in addition to the old
    support for the RequestHandler.include_host attribute).

tornado.websocket¶

  • Updated to support the latest version of the protocol, as finalized in RFC 6455.
  • Many bugs were fixed in all supported protocol versions.
  • tornado.websocket no longer supports the older “draft 76” version of the websocket protocol
    by default, although this version can be enabled by overriding 
    tornado.websocket.WebSocketHandler.allow_draft76.
  • WebSocketHandler.write_message now accepts a binary argument to send binary messages.
  • Subprotocols (i.e. the Sec-WebSocket-Protocol header) are now supported; see the
    WebSocketHandler.select_subprotocol method for details.
  • .WebSocketHandler.get_websocket_scheme can be used to select the appropriate url scheme (ws:
    // or wss://) in cases where HTTPRequest.protocol is not set correctly.

Other modules¶

  • tornado.auth.TwitterMixin.authenticate_redirect now takes a callback_uri parameter.
  • tornado.auth.TwitterMixin.twitter_request now accepts both URLs and partial paths (complete
    URLs are useful for the search API which follows different patterns).
  • Exception handling in tornado.gen has been improved. It is now possible to catch exceptions
    thrown by a Task.
  • tornado.netutil.bind_sockets now works when getaddrinfo returns duplicate addresses.
  • tornado.platform.twisted compatibility has been significantly improved. Twisted version
    11.1.0 is now supported in addition to 11.0.0.
  • tornado.process.fork_processes correctly reseeds the random module even when os.urandom is
    not implemented.
  • tornado.testing.main supports a new flag --exception_on_interrupt, which can be set to false
    to make Ctrl-C kill the process more reliably (at the expense of stack traces when it does
    so).
  • tornado.version_info is now a four-tuple so official releases can be distinguished from
    development branches.

What’s new in Tornado 2.1.1¶

Oct 4, 2011¶

Bug fixes¶

  • Fixed handling of closed connections with the epoll (i.e. Linux) IOLoop. Previously, closed
    connections could be shut down too early, which most often manifested as “Stream is closed”
    exceptions in SimpleAsyncHTTPClient.
  • Fixed a case in which chunked responses could be closed prematurely, leading to truncated
    output.
  • IOStream.connect now reports errors more consistently via logging and the close callback
    (this affects e.g. connections to localhost on FreeBSD).
  • IOStream.read_bytes again accepts both int and long arguments.
  • PeriodicCallback no longer runs repeatedly when IOLoop iterations complete faster than the
    resolution of time.time() (mainly a problem on Windows).

Backwards-compatibility note¶

  • Listening for IOLoop.ERROR alone is no longer sufficient for detecting closed connections on
    an otherwise unused socket. IOLoop.ERROR must always be used in combination with READ or 
    WRITE.

What’s new in Tornado 2.1¶

Sep 20, 2011¶

Backwards-incompatible changes¶

  • Support for secure cookies written by pre-1.0 releases of Tornado has been removed. The
    RequestHandler.get_secure_cookie method no longer takes an include_name parameter.
  • The debug application setting now causes stack traces to be displayed in the browser on
    uncaught exceptions. Since this may leak sensitive information, debug mode is not
    recommended for public-facing servers.

Security fixes¶

  • Diginotar has been removed from the default CA certificates file used by 
    SimpleAsyncHTTPClient.

New modules¶

  • tornado.gen: A generator-based interface to simplify writing asynchronous functions.
  • tornado.netutil: Parts of tornado.httpserver have been extracted into a new module for use
    with non-HTTP protocols.
  • tornado.platform.twisted: A bridge between the Tornado IOLoop and the Twisted Reactor,
    allowing code written for Twisted to be run on Tornado.
  • tornado.process: Multi-process mode has been improved, and can now restart crashed child
    processes. A new entry point has been added at tornado.process.fork_processes, although 
    tornado.httpserver.HTTPServer.start is still supported.

tornado.web¶

  • tornado.web.RequestHandler.write_error replaces get_error_html as the preferred way to
    generate custom error pages (get_error_html is still supported, but deprecated)
  • In tornado.web.Application, handlers may be specified by (fully-qualified) name instead of
    importing and passing the class object itself.
  • It is now possible to use a custom subclass of StaticFileHandler with the 
    static_handler_class application setting, and this subclass can override the behavior of the
    static_url method.
  • StaticFileHandler subclasses can now override get_cache_time to customize cache control
    behavior.
  • tornado.web.RequestHandler.get_secure_cookie now has a max_age_days parameter to allow
    applications to override the default one-month expiration.
  • set_cookie now accepts a max_age keyword argument to set the max-age cookie attribute (note
    underscore vs dash)
  • tornado.web.RequestHandler.set_default_headers may be overridden to set headers in a way
    that does not get reset during error handling.
  • RequestHandler.add_header can now be used to set a header that can appear multiple times in
    the response.
  • RequestHandler.flush can now take a callback for flow control.
  • The application/json content type can now be gzipped.
  • The cookie-signing functions are now accessible as static functions 
    tornado.web.create_signed_value and tornado.web.decode_signed_value.

tornado.httpserver¶

  • To facilitate some advanced multi-process scenarios, HTTPServer has a new method add_sockets
    , and socket-opening code is available separately as tornado.netutil.bind_sockets.
  • The cookies property is now available on tornado.httpserver.HTTPRequest (it is also
    available in its old location as a property of RequestHandler)
  • tornado.httpserver.HTTPServer.bind now takes a backlog argument with the same meaning as 
    socket.listen.
  • HTTPServer can now be run on a unix socket as well as TCP.
  • Fixed exception at startup when socket.AI_ADDRCONFIG is not available, as on Windows XP
